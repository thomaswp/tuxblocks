//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: pythagoras/f/CurveCrossingHelper.java
//
//  Created by Thomas on 7/9/13.
//

#import "IOSFloatArray.h"
#import "IOSIntArray.h"
#import "IOSObjectArray.h"
#import "java/lang/Math.h"
#import "java/util/ArrayList.h"
#import "java/util/Iterator.h"
#import "java/util/List.h"
#import "pythagoras/f/GeometryUtil.h"
#import "pythagoras/f/IntersectPoint.h"
#import "pythagoras/f/PathIterator.h"
#import "CurveCrossingHelper.h"

@implementation PythagorasFCurveCrossingHelper

- (IOSObjectArray *)coords {
  return coords_;
}
- (void)setCoords:(IOSObjectArray *)coords {
  JreOperatorRetainedAssign(&coords_, self, coords);
}
@synthesize coords = coords_;
- (IOSObjectArray *)rules {
  return rules_;
}
- (void)setRules:(IOSObjectArray *)rules {
  JreOperatorRetainedAssign(&rules_, self, rules);
}
@synthesize rules = rules_;
- (IOSIntArray *)sizes {
  return sizes_;
}
- (void)setSizes:(IOSIntArray *)sizes {
  JreOperatorRetainedAssign(&sizes_, self, sizes);
}
@synthesize sizes = sizes_;
- (IOSIntArray *)rulesSizes {
  return rulesSizes_;
}
- (void)setRulesSizes:(IOSIntArray *)rulesSizes {
  JreOperatorRetainedAssign(&rulesSizes_, self, rulesSizes);
}
@synthesize rulesSizes = rulesSizes_;
- (IOSObjectArray *)offsets {
  return offsets_;
}
- (void)setOffsets:(IOSObjectArray *)offsets {
  JreOperatorRetainedAssign(&offsets_, self, offsets);
}
@synthesize offsets = offsets_;
- (id<JavaUtilList>)isectPoints {
  return isectPoints_;
}
- (void)setIsectPoints:(id<JavaUtilList>)isectPoints {
  JreOperatorRetainedAssign(&isectPoints_, self, isectPoints);
}
@synthesize isectPoints = isectPoints_;

- (id)initWithJavaLangFloatArray:(IOSObjectArray *)coords
        withJavaLangIntegerArray:(IOSIntArray *)sizes
        withJavaLangIntegerArray:(IOSObjectArray *)rules
        withJavaLangIntegerArray:(IOSIntArray *)rulesSizes
        withJavaLangIntegerArray:(IOSObjectArray *)offsets {
  if ((self = [super init])) {
    JreOperatorRetainedAssign(&isectPoints_, self, [[[JavaUtilArrayList alloc] init] autorelease]);
    self.coords = coords;
    self.rules = rules;
    self.sizes = sizes;
    self.rulesSizes = rulesSizes;
    self.offsets = offsets;
  }
  return self;
}

- (IOSObjectArray *)findCrossing {
  IOSFloatArray *edge1 = [[[IOSFloatArray alloc] initWithLength:8] autorelease];
  IOSFloatArray *edge2 = [[[IOSFloatArray alloc] initWithLength:8] autorelease];
  IOSFloatArray *points = [[[IOSFloatArray alloc] initWithLength:6] autorelease];
  IOSFloatArray *params = [[[IOSFloatArray alloc] initWithLength:6] autorelease];
  IOSFloatArray *mp1 = [[[IOSFloatArray alloc] initWithLength:2] autorelease];
  IOSFloatArray *cp1 = [[[IOSFloatArray alloc] initWithLength:2] autorelease];
  IOSFloatArray *mp2 = [[[IOSFloatArray alloc] initWithLength:2] autorelease];
  IOSFloatArray *cp2 = [[[IOSFloatArray alloc] initWithLength:2] autorelease];
  int rule1, rule2, endIndex1, endIndex2;
  int ipCount = 0;
  for (int i = 0; i < [((IOSIntArray *) NIL_CHK(rulesSizes_)) intAtIndex:0]; i++) {
    rule1 = [((IOSIntArray *) [((IOSObjectArray *) NIL_CHK(rules_)) objectAtIndex:0]) intAtIndex:i];
    endIndex1 = [self currentEdgeWithInt:0 withInt:i withJavaLangFloatArray:edge1 withJavaLangFloatArray:mp1 withJavaLangFloatArray:cp1];
    for (int j = 0; j < [((IOSIntArray *) NIL_CHK(rulesSizes_)) intAtIndex:1]; j++) {
      ipCount = 0;
      rule2 = [((IOSIntArray *) [((IOSObjectArray *) NIL_CHK(rules_)) objectAtIndex:1]) intAtIndex:j];
      endIndex2 = [self currentEdgeWithInt:1 withInt:j withJavaLangFloatArray:edge2 withJavaLangFloatArray:mp2 withJavaLangFloatArray:cp2];
      if (((rule1 == PythagorasFPathIterator_SEG_LINETO) || (rule1 == PythagorasFPathIterator_SEG_CLOSE)) && ((rule2 == PythagorasFPathIterator_SEG_LINETO) || (rule2 == PythagorasFPathIterator_SEG_CLOSE))) {
        ipCount = [PythagorasFGeometryUtil intersectLinesWithParamsWithFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:3] withJavaLangFloatArray:params];
        if (ipCount != 0) {
          [((IOSFloatArray *) NIL_CHK(points)) replaceFloatAtIndex:0 withFloat:[PythagorasFGeometryUtil lineWithFloat:[((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:2]]];
          [((IOSFloatArray *) NIL_CHK(points)) replaceFloatAtIndex:1 withFloat:[PythagorasFGeometryUtil lineWithFloat:[((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:3]]];
        }
      }
      else if (((rule1 == PythagorasFPathIterator_SEG_LINETO) || (rule1 == PythagorasFPathIterator_SEG_CLOSE)) && (rule2 == PythagorasFPathIterator_SEG_QUADTO)) {
        ipCount = [PythagorasFGeometryUtil intersectLineAndQuadWithFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:4] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:5] withJavaLangFloatArray:params];
        for (int k = 0; k < ipCount; k++) {
          [((IOSFloatArray *) NIL_CHK(points)) replaceFloatAtIndex:2 * k withFloat:[PythagorasFGeometryUtil lineWithFloat:[((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:2 * k] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:2]]];
          [((IOSFloatArray *) NIL_CHK(points)) replaceFloatAtIndex:2 * k + 1 withFloat:[PythagorasFGeometryUtil lineWithFloat:[((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:2 * k] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:3]]];
        }
      }
      else if (rule1 == PythagorasFPathIterator_SEG_QUADTO && (rule2 == PythagorasFPathIterator_SEG_LINETO || rule2 == PythagorasFPathIterator_SEG_CLOSE)) {
        ipCount = [PythagorasFGeometryUtil intersectLineAndQuadWithFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:4] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:5] withJavaLangFloatArray:params];
        for (int k = 0; k < ipCount; k++) {
          [((IOSFloatArray *) NIL_CHK(points)) replaceFloatAtIndex:2 * k withFloat:[PythagorasFGeometryUtil lineWithFloat:[((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:2 * k + 1] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:2]]];
          [((IOSFloatArray *) NIL_CHK(points)) replaceFloatAtIndex:2 * k + 1 withFloat:[PythagorasFGeometryUtil lineWithFloat:[((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:2 * k + 1] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:3]]];
        }
      }
      else if ((rule1 == PythagorasFPathIterator_SEG_CUBICTO) && ((rule2 == PythagorasFPathIterator_SEG_LINETO) || (rule2 == PythagorasFPathIterator_SEG_CLOSE))) {
        ipCount = [PythagorasFGeometryUtil intersectLineAndCubicWithFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:4] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:5] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:6] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:7] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:3] withJavaLangFloatArray:params];
        for (int k = 0; k < ipCount; k++) {
          [((IOSFloatArray *) NIL_CHK(points)) replaceFloatAtIndex:2 * k withFloat:[PythagorasFGeometryUtil lineWithFloat:[((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:2 * k + 1] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:2]]];
          [((IOSFloatArray *) NIL_CHK(points)) replaceFloatAtIndex:2 * k + 1 withFloat:[PythagorasFGeometryUtil lineWithFloat:[((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:2 * k + 1] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:3]]];
        }
      }
      else if (((rule1 == PythagorasFPathIterator_SEG_LINETO) || (rule1 == PythagorasFPathIterator_SEG_CLOSE)) && (rule2 == PythagorasFPathIterator_SEG_CUBICTO)) {
        ipCount = [PythagorasFGeometryUtil intersectLineAndCubicWithFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:4] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:5] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:6] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:7] withJavaLangFloatArray:params];
        for (int k = 0; k < ipCount; k++) {
          [((IOSFloatArray *) NIL_CHK(points)) replaceFloatAtIndex:2 * k withFloat:[PythagorasFGeometryUtil lineWithFloat:[((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:2 * k] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:2]]];
          [((IOSFloatArray *) NIL_CHK(points)) replaceFloatAtIndex:2 * k + 1 withFloat:[PythagorasFGeometryUtil lineWithFloat:[((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:2 * k] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:3]]];
        }
      }
      else if ((rule1 == PythagorasFPathIterator_SEG_QUADTO) && (rule2 == PythagorasFPathIterator_SEG_QUADTO)) {
        ipCount = [PythagorasFGeometryUtil intersectQuadsWithFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:4] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:5] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:4] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:5] withJavaLangFloatArray:params];
        for (int k = 0; k < ipCount; k++) {
          [((IOSFloatArray *) NIL_CHK(points)) replaceFloatAtIndex:2 * k withFloat:[PythagorasFGeometryUtil quadWithFloat:[((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:2 * k] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:4]]];
          [((IOSFloatArray *) NIL_CHK(points)) replaceFloatAtIndex:2 * k + 1 withFloat:[PythagorasFGeometryUtil quadWithFloat:[((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:2 * k] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:5]]];
        }
      }
      else if ((rule1 == PythagorasFPathIterator_SEG_QUADTO) && (rule2 == PythagorasFPathIterator_SEG_CUBICTO)) {
        ipCount = [PythagorasFGeometryUtil intersectQuadAndCubicWithFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:4] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:5] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:4] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:5] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:6] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:7] withJavaLangFloatArray:params];
        for (int k = 0; k < ipCount; k++) {
          [((IOSFloatArray *) NIL_CHK(points)) replaceFloatAtIndex:2 * k withFloat:[PythagorasFGeometryUtil quadWithFloat:[((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:2 * k] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:4]]];
          [((IOSFloatArray *) NIL_CHK(points)) replaceFloatAtIndex:2 * k + 1 withFloat:[PythagorasFGeometryUtil quadWithFloat:[((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:2 * k] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:5]]];
        }
      }
      else if ((rule1 == PythagorasFPathIterator_SEG_CUBICTO) && (rule2 == PythagorasFPathIterator_SEG_QUADTO)) {
        ipCount = [PythagorasFGeometryUtil intersectQuadAndCubicWithFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:4] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:5] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:4] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:5] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:6] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:7] withJavaLangFloatArray:params];
        for (int k = 0; k < ipCount; k++) {
          [((IOSFloatArray *) NIL_CHK(points)) replaceFloatAtIndex:2 * k withFloat:[PythagorasFGeometryUtil quadWithFloat:[((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:2 * k + 1] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:4]]];
          [((IOSFloatArray *) NIL_CHK(points)) replaceFloatAtIndex:2 * k + 1 withFloat:[PythagorasFGeometryUtil quadWithFloat:[((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:2 * k + 1] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:5]]];
        }
      }
      else if ((rule1 == PythagorasFPathIterator_SEG_CUBICTO) && (rule2 == PythagorasFPathIterator_SEG_CUBICTO)) {
        ipCount = [PythagorasFGeometryUtil intersectCubicsWithFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:4] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:5] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:6] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:7] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:4] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:5] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:6] withFloat:[((IOSFloatArray *) NIL_CHK(edge2)) floatAtIndex:7] withJavaLangFloatArray:params];
        for (int k = 0; k < ipCount; k++) {
          [((IOSFloatArray *) NIL_CHK(points)) replaceFloatAtIndex:2 * k withFloat:[PythagorasFGeometryUtil cubicWithFloat:[((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:2 * k] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:0] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:2] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:4] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:6]]];
          [((IOSFloatArray *) NIL_CHK(points)) replaceFloatAtIndex:2 * k + 1 withFloat:[PythagorasFGeometryUtil cubicWithFloat:[((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:2 * k] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:1] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:3] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:5] withFloat:[((IOSFloatArray *) NIL_CHK(edge1)) floatAtIndex:7]]];
        }
      }
      endIndex1 = i;
      endIndex2 = j;
      int begIndex1 = i - 1;
      int begIndex2 = j - 1;
      for (int k = 0; k < ipCount; k++) {
        PythagorasFIntersectPoint *ip = nil;
        if (![self containsPointWithFloat:[((IOSFloatArray *) NIL_CHK(points)) floatAtIndex:2 * k] withFloat:[((IOSFloatArray *) NIL_CHK(points)) floatAtIndex:2 * k + 1]]) {
          for (id<JavaUtilIterator> iter = ((id<JavaUtilIterator>) [((id<JavaUtilList>) NIL_CHK(isectPoints_)) iterator]); [((id<JavaUtilIterator>) NIL_CHK(iter)) hasNext]; ) {
            ip = ((PythagorasFIntersectPoint *) [((id<JavaUtilIterator>) NIL_CHK(iter)) next]);
            if ((begIndex1 == [((PythagorasFIntersectPoint *) NIL_CHK(ip)) begIndexWithBOOL:YES]) && (endIndex1 == [((PythagorasFIntersectPoint *) NIL_CHK(ip)) endIndexWithBOOL:YES])) {
              if ([((PythagorasFIntersectPoint *) NIL_CHK(ip)) paramWithBOOL:YES] > [((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:2 * k]) {
                endIndex1 = -([((id<JavaUtilList>) NIL_CHK(isectPoints_)) indexOfWithId:ip] + 1);
                [((PythagorasFIntersectPoint *) NIL_CHK(ip)) setBegIndex1WithInt:-([((id<JavaUtilList>) NIL_CHK(isectPoints_)) size] + 1)];
              }
              else {
                begIndex1 = -([((id<JavaUtilList>) NIL_CHK(isectPoints_)) indexOfWithId:ip] + 1);
                [((PythagorasFIntersectPoint *) NIL_CHK(ip)) setEndIndex1WithInt:-([((id<JavaUtilList>) NIL_CHK(isectPoints_)) size] + 1)];
              }
            }
            if ((begIndex2 == [((PythagorasFIntersectPoint *) NIL_CHK(ip)) begIndexWithBOOL:NO]) && (endIndex2 == [((PythagorasFIntersectPoint *) NIL_CHK(ip)) endIndexWithBOOL:NO])) {
              if ([((PythagorasFIntersectPoint *) NIL_CHK(ip)) paramWithBOOL:NO] > [((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:2 * k + 1]) {
                endIndex2 = -([((id<JavaUtilList>) NIL_CHK(isectPoints_)) indexOfWithId:ip] + 1);
                [((PythagorasFIntersectPoint *) NIL_CHK(ip)) setBegIndex2WithInt:-([((id<JavaUtilList>) NIL_CHK(isectPoints_)) size] + 1)];
              }
              else {
                begIndex2 = -([((id<JavaUtilList>) NIL_CHK(isectPoints_)) indexOfWithId:ip] + 1);
                [((PythagorasFIntersectPoint *) NIL_CHK(ip)) setEndIndex2WithInt:-([((id<JavaUtilList>) NIL_CHK(isectPoints_)) size] + 1)];
              }
            }
          }
          if (rule1 == PythagorasFPathIterator_SEG_CLOSE) {
            rule1 = PythagorasFPathIterator_SEG_LINETO;
          }
          if (rule2 == PythagorasFPathIterator_SEG_CLOSE) {
            rule2 = PythagorasFPathIterator_SEG_LINETO;
          }
          [((id<JavaUtilList>) NIL_CHK(isectPoints_)) addWithId:[[[PythagorasFIntersectPoint alloc] initWithInt:begIndex1 withInt:endIndex1 withInt:rule1 withInt:i withInt:begIndex2 withInt:endIndex2 withInt:rule2 withInt:j withFloat:[((IOSFloatArray *) NIL_CHK(points)) floatAtIndex:2 * k] withFloat:[((IOSFloatArray *) NIL_CHK(points)) floatAtIndex:2 * k + 1] withFloat:[((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:2 * k] withFloat:[((IOSFloatArray *) NIL_CHK(params)) floatAtIndex:2 * k + 1]] autorelease]];
        }
      }
    }
  }
  return [((id<JavaUtilList>) NIL_CHK(isectPoints_)) toArrayWithNSObjectArray:[[[IOSObjectArray alloc] initWithLength:[((id<JavaUtilList>) NIL_CHK(isectPoints_)) size] type:[IOSClass classWithClass:[PythagorasFIntersectPoint class]]] autorelease]];
}

- (int)currentEdgeWithInt:(int)areaIndex
                  withInt:(int)index
   withJavaLangFloatArray:(IOSFloatArray *)c
   withJavaLangFloatArray:(IOSFloatArray *)mp
   withJavaLangFloatArray:(IOSFloatArray *)cp {
  int endIndex = 0;
  switch ([((IOSIntArray *) [((IOSObjectArray *) NIL_CHK(rules_)) objectAtIndex:areaIndex]) intAtIndex:index]) {
    case PythagorasFPathIterator_SEG_MOVETO:
    [((IOSFloatArray *) NIL_CHK(cp)) replaceFloatAtIndex:0 withFloat:[((IOSFloatArray *) NIL_CHK(mp)) replaceFloatAtIndex:0 withFloat:[((IOSFloatArray *) [((IOSObjectArray *) NIL_CHK(coords_)) objectAtIndex:areaIndex]) floatAtIndex:[((IOSIntArray *) [((IOSObjectArray *) NIL_CHK(offsets_)) objectAtIndex:areaIndex]) intAtIndex:index]]]];
    [((IOSFloatArray *) NIL_CHK(cp)) replaceFloatAtIndex:1 withFloat:[((IOSFloatArray *) NIL_CHK(mp)) replaceFloatAtIndex:1 withFloat:[((IOSFloatArray *) [((IOSObjectArray *) NIL_CHK(coords_)) objectAtIndex:areaIndex]) floatAtIndex:[((IOSIntArray *) [((IOSObjectArray *) NIL_CHK(offsets_)) objectAtIndex:areaIndex]) intAtIndex:index] + 1]]];
    break;
    case PythagorasFPathIterator_SEG_LINETO:
    [((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:0 withFloat:[((IOSFloatArray *) NIL_CHK(cp)) floatAtIndex:0]];
    [((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:1 withFloat:[((IOSFloatArray *) NIL_CHK(cp)) floatAtIndex:1]];
    [((IOSFloatArray *) NIL_CHK(cp)) replaceFloatAtIndex:0 withFloat:[((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:2 withFloat:[((IOSFloatArray *) [((IOSObjectArray *) NIL_CHK(coords_)) objectAtIndex:areaIndex]) floatAtIndex:[((IOSIntArray *) [((IOSObjectArray *) NIL_CHK(offsets_)) objectAtIndex:areaIndex]) intAtIndex:index]]]];
    [((IOSFloatArray *) NIL_CHK(cp)) replaceFloatAtIndex:1 withFloat:[((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:3 withFloat:[((IOSFloatArray *) [((IOSObjectArray *) NIL_CHK(coords_)) objectAtIndex:areaIndex]) floatAtIndex:[((IOSIntArray *) [((IOSObjectArray *) NIL_CHK(offsets_)) objectAtIndex:areaIndex]) intAtIndex:index] + 1]]];
    endIndex = 0;
    break;
    case PythagorasFPathIterator_SEG_QUADTO:
    [((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:0 withFloat:[((IOSFloatArray *) NIL_CHK(cp)) floatAtIndex:0]];
    [((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:1 withFloat:[((IOSFloatArray *) NIL_CHK(cp)) floatAtIndex:1]];
    [((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:2 withFloat:[((IOSFloatArray *) [((IOSObjectArray *) NIL_CHK(coords_)) objectAtIndex:areaIndex]) floatAtIndex:[((IOSIntArray *) [((IOSObjectArray *) NIL_CHK(offsets_)) objectAtIndex:areaIndex]) intAtIndex:index]]];
    [((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:3 withFloat:[((IOSFloatArray *) [((IOSObjectArray *) NIL_CHK(coords_)) objectAtIndex:areaIndex]) floatAtIndex:[((IOSIntArray *) [((IOSObjectArray *) NIL_CHK(offsets_)) objectAtIndex:areaIndex]) intAtIndex:index] + 1]];
    [((IOSFloatArray *) NIL_CHK(cp)) replaceFloatAtIndex:0 withFloat:[((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:4 withFloat:[((IOSFloatArray *) [((IOSObjectArray *) NIL_CHK(coords_)) objectAtIndex:areaIndex]) floatAtIndex:[((IOSIntArray *) [((IOSObjectArray *) NIL_CHK(offsets_)) objectAtIndex:areaIndex]) intAtIndex:index] + 2]]];
    [((IOSFloatArray *) NIL_CHK(cp)) replaceFloatAtIndex:1 withFloat:[((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:5 withFloat:[((IOSFloatArray *) [((IOSObjectArray *) NIL_CHK(coords_)) objectAtIndex:areaIndex]) floatAtIndex:[((IOSIntArray *) [((IOSObjectArray *) NIL_CHK(offsets_)) objectAtIndex:areaIndex]) intAtIndex:index] + 3]]];
    endIndex = 2;
    break;
    case PythagorasFPathIterator_SEG_CUBICTO:
    [((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:0 withFloat:[((IOSFloatArray *) NIL_CHK(cp)) floatAtIndex:0]];
    [((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:1 withFloat:[((IOSFloatArray *) NIL_CHK(cp)) floatAtIndex:1]];
    [((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:2 withFloat:[((IOSFloatArray *) [((IOSObjectArray *) NIL_CHK(coords_)) objectAtIndex:areaIndex]) floatAtIndex:[((IOSIntArray *) [((IOSObjectArray *) NIL_CHK(offsets_)) objectAtIndex:areaIndex]) intAtIndex:index]]];
    [((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:3 withFloat:[((IOSFloatArray *) [((IOSObjectArray *) NIL_CHK(coords_)) objectAtIndex:areaIndex]) floatAtIndex:[((IOSIntArray *) [((IOSObjectArray *) NIL_CHK(offsets_)) objectAtIndex:areaIndex]) intAtIndex:index] + 1]];
    [((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:4 withFloat:[((IOSFloatArray *) [((IOSObjectArray *) NIL_CHK(coords_)) objectAtIndex:areaIndex]) floatAtIndex:[((IOSIntArray *) [((IOSObjectArray *) NIL_CHK(offsets_)) objectAtIndex:areaIndex]) intAtIndex:index] + 2]];
    [((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:5 withFloat:[((IOSFloatArray *) [((IOSObjectArray *) NIL_CHK(coords_)) objectAtIndex:areaIndex]) floatAtIndex:[((IOSIntArray *) [((IOSObjectArray *) NIL_CHK(offsets_)) objectAtIndex:areaIndex]) intAtIndex:index] + 3]];
    [((IOSFloatArray *) NIL_CHK(cp)) replaceFloatAtIndex:0 withFloat:[((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:6 withFloat:[((IOSFloatArray *) [((IOSObjectArray *) NIL_CHK(coords_)) objectAtIndex:areaIndex]) floatAtIndex:[((IOSIntArray *) [((IOSObjectArray *) NIL_CHK(offsets_)) objectAtIndex:areaIndex]) intAtIndex:index] + 4]]];
    [((IOSFloatArray *) NIL_CHK(cp)) replaceFloatAtIndex:1 withFloat:[((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:7 withFloat:[((IOSFloatArray *) [((IOSObjectArray *) NIL_CHK(coords_)) objectAtIndex:areaIndex]) floatAtIndex:[((IOSIntArray *) [((IOSObjectArray *) NIL_CHK(offsets_)) objectAtIndex:areaIndex]) intAtIndex:index] + 5]]];
    endIndex = 4;
    break;
    case PythagorasFPathIterator_SEG_CLOSE:
    [((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:0 withFloat:[((IOSFloatArray *) NIL_CHK(cp)) floatAtIndex:0]];
    [((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:1 withFloat:[((IOSFloatArray *) NIL_CHK(cp)) floatAtIndex:1]];
    [((IOSFloatArray *) NIL_CHK(cp)) replaceFloatAtIndex:0 withFloat:[((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:2 withFloat:[((IOSFloatArray *) NIL_CHK(mp)) floatAtIndex:0]]];
    [((IOSFloatArray *) NIL_CHK(cp)) replaceFloatAtIndex:1 withFloat:[((IOSFloatArray *) NIL_CHK(c)) replaceFloatAtIndex:3 withFloat:[((IOSFloatArray *) NIL_CHK(mp)) floatAtIndex:1]]];
    if ([((IOSIntArray *) [((IOSObjectArray *) NIL_CHK(offsets_)) objectAtIndex:areaIndex]) intAtIndex:index] >= [((IOSIntArray *) NIL_CHK(sizes_)) intAtIndex:areaIndex]) {
      endIndex = -[((IOSIntArray *) NIL_CHK(sizes_)) intAtIndex:areaIndex];
    }
    else {
      endIndex = 0;
    }
    break;
  }
  return [((IOSIntArray *) [((IOSObjectArray *) NIL_CHK(offsets_)) objectAtIndex:areaIndex]) intAtIndex:index] + endIndex;
}

- (BOOL)containsPointWithFloat:(float)x
                     withFloat:(float)y {
  PythagorasFIntersectPoint *ipoint;
  for (id<JavaUtilIterator> i = ((id<JavaUtilIterator>) [((id<JavaUtilList>) NIL_CHK(isectPoints_)) iterator]); [((id<JavaUtilIterator>) NIL_CHK(i)) hasNext]; ) {
    ipoint = ((PythagorasFIntersectPoint *) [((id<JavaUtilIterator>) NIL_CHK(i)) next]);
    if (([JavaLangMath absWithFloat:[((PythagorasFIntersectPoint *) NIL_CHK(ipoint)) x] - x] < [JavaLangMath powWithDouble:10 withDouble:-6]) && ([JavaLangMath absWithFloat:[((PythagorasFIntersectPoint *) NIL_CHK(ipoint)) y] - y] < [JavaLangMath powWithDouble:10 withDouble:-6])) {
      return YES;
    }
  }
  return NO;
}

- (void)dealloc {
  JreOperatorRetainedAssign(&isectPoints_, self, nil);
  JreOperatorRetainedAssign(&offsets_, self, nil);
  JreOperatorRetainedAssign(&rulesSizes_, self, nil);
  JreOperatorRetainedAssign(&sizes_, self, nil);
  JreOperatorRetainedAssign(&rules_, self, nil);
  JreOperatorRetainedAssign(&coords_, self, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  PythagorasFCurveCrossingHelper *typedCopy = (PythagorasFCurveCrossingHelper *) copy;
  typedCopy.coords = coords_;
  typedCopy.rules = rules_;
  typedCopy.sizes = sizes_;
  typedCopy.rulesSizes = rulesSizes_;
  typedCopy.offsets = offsets_;
  typedCopy.isectPoints = isectPoints_;
}

@end
