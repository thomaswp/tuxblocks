//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: playn/core/gl/AbstractSurfaceGL.java
//
//  Created by Thomas on 7/1/13.
//

#import "IOSFloatArray.h"
#import "IOSIntArray.h"
#import "java/lang/IllegalStateException.h"
#import "java/lang/Math.h"
#import "java/util/ArrayList.h"
#import "java/util/List.h"
#import "playn/core/Asserts.h"
#import "playn/core/Image.h"
#import "playn/core/InternalTransform.h"
#import "playn/core/Layer.h"
#import "playn/core/Pattern.h"
#import "playn/core/Surface.h"
#import "playn/core/Tint.h"
#import "playn/core/gl/AbstractImageGL.h"
#import "playn/core/gl/GLContext.h"
#import "playn/core/gl/GLPattern.h"
#import "playn/core/gl/GLShader.h"
#import "playn/core/gl/LayerGL.h"
#import "pythagoras/f/FloatMath.h"
#import "pythagoras/f/MathUtil.h"
#import "pythagoras/f/Transform.h"

@implementation PlaynCoreGlAbstractSurfaceGL

- (PlaynCoreGlGLContext *)ctx {
  return ctx_;
}
- (void)setCtx:(PlaynCoreGlGLContext *)ctx {
  JreOperatorRetainedAssign(&ctx_, self, ctx);
}
@synthesize ctx = ctx_;
- (id<JavaUtilList>)transformStack {
  return transformStack_;
}
- (void)setTransformStack:(id<JavaUtilList>)transformStack {
  JreOperatorRetainedAssign(&transformStack_, self, transformStack);
}
@synthesize transformStack = transformStack_;
@synthesize fillColor = fillColor_;
@synthesize tint = tint_;
- (PlaynCoreGlAbstractImageGL *)fillPattern {
  return fillPattern_;
}
- (void)setFillPattern:(PlaynCoreGlAbstractImageGL *)fillPattern {
  JreOperatorRetainedAssign(&fillPattern_, self, fillPattern);
}
@synthesize fillPattern = fillPattern_;
- (PlaynCoreGlGLShader *)shader {
  return shader_;
}
- (void)setShader:(PlaynCoreGlGLShader *)shader {
  JreOperatorRetainedAssign(&shader_, self, shader);
}
@synthesize shader = shader_;

- (id)initWithPlaynCoreGlGLContext:(PlaynCoreGlGLContext *)ctx {
  if ((self = [super init])) {
    JreOperatorRetainedAssign(&transformStack_, self, [[[JavaUtilArrayList alloc] init] autorelease]);
    tint_ = PlaynCoreTint_NOOP_TINT;
    self.ctx = ctx;
    [((id<JavaUtilList>) NIL_CHK(transformStack_)) addWithId:[((PlaynCoreGlGLContext *) NIL_CHK(ctx)) createTransform]];
  }
  return self;
}

- (void)bindFramebuffer {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (id<PlaynCoreSurface>)clear {
  [self bindFramebuffer];
  [((PlaynCoreGlGLContext *) NIL_CHK(ctx_)) clearWithFloat:0 withFloat:0 withFloat:0 withFloat:0];
  return self;
}

- (id<PlaynCoreSurface>)drawImageWithPlaynCoreImage:(id<PlaynCoreImage>)image
                                          withFloat:(float)x
                                          withFloat:(float)y {
  return [self drawImageWithPlaynCoreImage:image withFloat:x withFloat:y withFloat:[((id<PlaynCoreImage>) NIL_CHK(image)) width] withFloat:[((id<PlaynCoreImage>) NIL_CHK(image)) height]];
}

- (id<PlaynCoreSurface>)drawImageWithPlaynCoreImage:(id<PlaynCoreImage>)image
                                          withFloat:(float)x
                                          withFloat:(float)y
                                          withFloat:(float)dw
                                          withFloat:(float)dh {
  [self bindFramebuffer];
  [((PlaynCoreGlAbstractImageGL *) image) drawWithPlaynCoreGlGLShader:shader_ withPlaynCoreInternalTransform:[self topTransform] withInt:tint_ withFloat:x withFloat:y withFloat:dw withFloat:dh];
  return self;
}

- (id<PlaynCoreSurface>)drawImageWithPlaynCoreImage:(id<PlaynCoreImage>)image
                                          withFloat:(float)dx
                                          withFloat:(float)dy
                                          withFloat:(float)dw
                                          withFloat:(float)dh
                                          withFloat:(float)sx
                                          withFloat:(float)sy
                                          withFloat:(float)sw
                                          withFloat:(float)sh {
  [self bindFramebuffer];
  [((PlaynCoreGlAbstractImageGL *) image) drawWithPlaynCoreGlGLShader:shader_ withPlaynCoreInternalTransform:[self topTransform] withInt:tint_ withFloat:dx withFloat:dy withFloat:dw withFloat:dh withFloat:sx withFloat:sy withFloat:sw withFloat:sh];
  return self;
}

- (id<PlaynCoreSurface>)drawImageCenteredWithPlaynCoreImage:(id<PlaynCoreImage>)img
                                                  withFloat:(float)x
                                                  withFloat:(float)y {
  return [self drawImageWithPlaynCoreImage:img withFloat:x - [((id<PlaynCoreImage>) NIL_CHK(img)) width] / 2 withFloat:y - [((id<PlaynCoreImage>) NIL_CHK(img)) height] / 2];
}

- (id<PlaynCoreSurface>)drawLayerWithPlaynCoreLayer:(id<PlaynCoreLayer>)layer {
  [self bindFramebuffer];
  [((PlaynCoreGlLayerGL *) layer) paintWithPlaynCoreInternalTransform:[self topTransform] withInt:tint_ withPlaynCoreGlGLShader:shader_];
  return self;
}

- (id<PlaynCoreSurface>)drawLineWithFloat:(float)x0
                                withFloat:(float)y0
                                withFloat:(float)x1
                                withFloat:(float)y1
                                withFloat:(float)width {
  [self bindFramebuffer];
  if (x1 < x0) {
    float temp = x0;
    x0 = x1;
    x1 = temp;
    temp = y0;
    y0 = y1;
    y1 = temp;
  }
  float dx = x1 - x0, dy = y1 - y0;
  float length = [PythagorasFFloatMath sqrtWithFloat:dx * dx + dy * dy];
  float wx = dx * (width / 2) / length;
  float wy = dy * (width / 2) / length;
  id<PlaynCoreInternalTransform> l = [((PlaynCoreGlGLContext *) NIL_CHK(ctx_)) createTransform];
  (void) [((id<PlaynCoreInternalTransform>) NIL_CHK(l)) setRotationWithFloat:[PythagorasFFloatMath atan2WithFloat:dy withFloat:dx]];
  (void) [((id<PlaynCoreInternalTransform>) NIL_CHK(l)) setTranslationWithFloat:x0 + wy withFloat:y0 - wx];
  (void) [((id<PlaynCoreInternalTransform>) NIL_CHK(l)) preConcatenateWithPlaynCoreInternalTransform:[self topTransform]];
  PlaynCoreGlGLShader *shader = [((PlaynCoreGlGLContext *) NIL_CHK(ctx_)) quadShaderWithPlaynCoreGlGLShader:self.shader];
  if (fillPattern_ != nil) {
    int tex = [fillPattern_ ensureTexture];
    if (tex > 0) {
      (void) [((PlaynCoreGlGLShader *) NIL_CHK(shader)) prepareTextureWithInt:tex withInt:tint_];
      [((PlaynCoreGlGLShader *) NIL_CHK(shader)) addQuadWithPlaynCoreInternalTransform:l withFloat:0 withFloat:0 withFloat:length withFloat:width withFloat:0 withFloat:0 withFloat:length / [fillPattern_ width] withFloat:width / [fillPattern_ height]];
    }
  }
  else {
    (void) [((PlaynCoreGlGLShader *) NIL_CHK(shader)) prepareColorWithInt:[PlaynCoreTint combineWithInt:fillColor_ withInt:tint_]];
    [((PlaynCoreGlGLShader *) NIL_CHK(shader)) addQuadWithPlaynCoreInternalTransform:l withFloat:0 withFloat:0 withFloat:length withFloat:width withFloat:0 withFloat:0 withFloat:1 withFloat:1];
  }
  return self;
}

- (id<PlaynCoreSurface>)fillRectWithFloat:(float)x
                                withFloat:(float)y
                                withFloat:(float)width
                                withFloat:(float)height {
  [self bindFramebuffer];
  PlaynCoreGlGLShader *shader = [((PlaynCoreGlGLContext *) NIL_CHK(ctx_)) quadShaderWithPlaynCoreGlGLShader:self.shader];
  if (fillPattern_ != nil) {
    int tex = [fillPattern_ ensureTexture];
    if (tex > 0) {
      (void) [((PlaynCoreGlGLShader *) NIL_CHK(shader)) prepareTextureWithInt:tex withInt:tint_];
      float tw = [fillPattern_ width], th = [fillPattern_ height], r = x + width, b = y + height;
      [((PlaynCoreGlGLShader *) NIL_CHK(shader)) addQuadWithPlaynCoreInternalTransform:[self topTransform] withFloat:x withFloat:y withFloat:x + width withFloat:y + height withFloat:x / tw withFloat:y / th withFloat:r / tw withFloat:b / th];
    }
  }
  else {
    (void) [((PlaynCoreGlGLShader *) NIL_CHK(shader)) prepareColorWithInt:[PlaynCoreTint combineWithInt:fillColor_ withInt:tint_]];
    [((PlaynCoreGlGLShader *) NIL_CHK(shader)) addQuadWithPlaynCoreInternalTransform:[self topTransform] withFloat:x withFloat:y withFloat:x + width withFloat:y + height withFloat:0 withFloat:0 withFloat:1 withFloat:1];
  }
  return self;
}

- (id<PlaynCoreSurface>)fillTrianglesWithJavaLangFloatArray:(IOSFloatArray *)xys
                                   withJavaLangIntegerArray:(IOSIntArray *)indices {
  [self bindFramebuffer];
  PlaynCoreGlGLShader *shader = [((PlaynCoreGlGLContext *) NIL_CHK(ctx_)) trisShaderWithPlaynCoreGlGLShader:self.shader];
  if (fillPattern_ != nil) {
    int tex = [fillPattern_ ensureTexture];
    if (tex > 0) {
      (void) [((PlaynCoreGlGLShader *) NIL_CHK(shader)) prepareTextureWithInt:tex withInt:tint_];
      [((PlaynCoreGlGLShader *) NIL_CHK(shader)) addTrianglesWithPlaynCoreInternalTransform:[self topTransform] withJavaLangFloatArray:xys withFloat:[fillPattern_ width] withFloat:[fillPattern_ height] withJavaLangIntegerArray:indices];
    }
  }
  else {
    (void) [((PlaynCoreGlGLShader *) NIL_CHK(shader)) prepareColorWithInt:[PlaynCoreTint combineWithInt:fillColor_ withInt:tint_]];
    [((PlaynCoreGlGLShader *) NIL_CHK(shader)) addTrianglesWithPlaynCoreInternalTransform:[self topTransform] withJavaLangFloatArray:xys withFloat:1 withFloat:1 withJavaLangIntegerArray:indices];
  }
  return self;
}

- (id<PlaynCoreSurface>)fillTrianglesWithJavaLangFloatArray:(IOSFloatArray *)xys
                                     withJavaLangFloatArray:(IOSFloatArray *)sxys
                                   withJavaLangIntegerArray:(IOSIntArray *)indices {
  [self bindFramebuffer];
  if (fillPattern_ == nil) @throw [[[JavaLangIllegalStateException alloc] initWithNSString:@"No fill pattern currently set"] autorelease];
  int tex = [((PlaynCoreGlAbstractImageGL *) NIL_CHK(fillPattern_)) ensureTexture];
  if (tex > 0) {
    PlaynCoreGlGLShader *shader = [[((PlaynCoreGlGLContext *) NIL_CHK(ctx_)) trisShaderWithPlaynCoreGlGLShader:self.shader] prepareTextureWithInt:tex withInt:tint_];
    [((PlaynCoreGlGLShader *) NIL_CHK(shader)) addTrianglesWithPlaynCoreInternalTransform:[self topTransform] withJavaLangFloatArray:xys withJavaLangFloatArray:sxys withJavaLangIntegerArray:indices];
  }
  return self;
}

- (id<PlaynCoreSurface>)restore {
  [PlaynCoreAsserts checkStateWithBOOL:[((id<JavaUtilList>) NIL_CHK(transformStack_)) size] > 1 withId:@"Unbalanced save/restore"];
  (void) [((id<JavaUtilList>) NIL_CHK(transformStack_)) removeWithInt:[((id<JavaUtilList>) NIL_CHK(transformStack_)) size] - 1];
  return self;
}

- (id<PlaynCoreSurface>)rotateWithFloat:(float)angle {
  float sr = (float) [JavaLangMath sinWithDouble:angle];
  float cr = (float) [JavaLangMath cosWithDouble:angle];
  (void) [self transformWithFloat:cr withFloat:sr withFloat:-sr withFloat:cr withFloat:0 withFloat:0];
  return self;
}

- (id<PlaynCoreSurface>)save {
  [((id<JavaUtilList>) NIL_CHK(transformStack_)) addWithId:[((id<PlaynCoreInternalTransform>) [((PlaynCoreGlGLContext *) NIL_CHK(ctx_)) createTransform]) setWithPythagorasFTransform:[self topTransform]]];
  return self;
}

- (id<PlaynCoreSurface>)scale__WithFloat:(float)sx
                               withFloat:(float)sy {
  (void) [((id<PlaynCoreInternalTransform>) [self topTransform]) scale__WithFloat:sx withFloat:sy];
  return self;
}

- (id<PlaynCoreSurface>)setTransformWithFloat:(float)m00
                                    withFloat:(float)m01
                                    withFloat:(float)m10
                                    withFloat:(float)m11
                                    withFloat:(float)tx
                                    withFloat:(float)ty {
  (void) [((id<PlaynCoreInternalTransform>) [self topTransform]) setTransformWithFloat:m00 withFloat:m01 withFloat:m10 withFloat:m11 withFloat:tx withFloat:ty];
  return self;
}

- (id<PlaynCoreSurface>)setAlphaWithFloat:(float)alpha {
  int ialpha = (int) ((int) 0xFF * [PythagorasFMathUtil clampWithFloat:alpha withFloat:0 withFloat:1]);
  self.tint = (ialpha << 24) | (tint_ & (int) 0xFFFFFF);
  return self;
}

- (id<PlaynCoreSurface>)setTintWithInt:(int)tint {
  self.tint = tint;
  return self;
}

- (id<PlaynCoreSurface>)setFillColorWithInt:(int)color {
  self.fillColor = color;
  self.fillPattern = nil;
  return self;
}

- (id<PlaynCoreSurface>)setFillPatternWithPlaynCorePattern:(id<PlaynCorePattern>)pattern {
  [PlaynCoreAsserts checkArgumentWithBOOL:[(id) pattern conformsToProtocol: @protocol(PlaynCoreGlGLPattern)]];
  self.fillPattern = [((id<PlaynCoreGlGLPattern>) pattern) image];
  [((PlaynCoreGlAbstractImageGL *) NIL_CHK(self.fillPattern)) setRepeatWithBOOL:YES withBOOL:YES];
  return self;
}

- (id<PlaynCoreSurface>)setShaderWithPlaynCoreGlGLShader:(PlaynCoreGlGLShader *)shader {
  self.shader = shader;
  return self;
}

- (id<PlaynCoreSurface>)transformWithFloat:(float)m00
                                 withFloat:(float)m01
                                 withFloat:(float)m10
                                 withFloat:(float)m11
                                 withFloat:(float)tx
                                 withFloat:(float)ty {
  (void) [((id<PlaynCoreInternalTransform>) [self topTransform]) concatenateWithFloat:m00 withFloat:m01 withFloat:m10 withFloat:m11 withFloat:tx withFloat:ty withFloat:0 withFloat:0];
  return self;
}

- (id<PlaynCoreSurface>)translateWithFloat:(float)x
                                 withFloat:(float)y {
  (void) [((id<PlaynCoreInternalTransform>) [self topTransform]) translateWithFloat:x withFloat:y];
  return self;
}

- (id<PlaynCoreInternalTransform>)topTransform {
  return ((id<PlaynCoreInternalTransform>) [((id<JavaUtilList>) NIL_CHK(transformStack_)) getWithInt:[((id<JavaUtilList>) NIL_CHK(transformStack_)) size] - 1]);
}

- (float)height {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (float)width {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (void)dealloc {
  JreOperatorRetainedAssign(&shader_, self, nil);
  JreOperatorRetainedAssign(&fillPattern_, self, nil);
  JreOperatorRetainedAssign(&transformStack_, self, nil);
  JreOperatorRetainedAssign(&ctx_, self, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  PlaynCoreGlAbstractSurfaceGL *typedCopy = (PlaynCoreGlAbstractSurfaceGL *) copy;
  typedCopy.ctx = ctx_;
  typedCopy.transformStack = transformStack_;
  typedCopy.fillColor = fillColor_;
  typedCopy.tint = tint_;
  typedCopy.fillPattern = fillPattern_;
  typedCopy.shader = shader_;
}

@end
