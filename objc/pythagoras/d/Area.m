//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: pythagoras/d/Area.java
//
//  Created by Thomas on 7/1/13.
//

#import "Crossing.h"
#import "CrossingHelper.h"
#import "CurveCrossingHelper.h"
#import "FlatteningPathIterator.h"
#import "GeometryUtil.h"
#import "IOSClass.h"
#import "IOSDoubleArray.h"
#import "IOSIntArray.h"
#import "IOSObjectArray.h"
#import "IPoint.h"
#import "IRectangle.h"
#import "IShape.h"
#import "IntersectPoint.h"
#import "PathIterator.h"
#import "Platform.h"
#import "Rectangle.h"
#import "Transform.h"
#import "Transforms.h"
#import "java/lang/Math.h"
#import "java/lang/System.h"
#import "java/util/NoSuchElementException.h"

@implementation PythagorasDArea

- (IOSDoubleArray *)coords {
  return coords_;
}
- (void)setCoords:(IOSDoubleArray *)coords {
  JreOperatorRetainedAssign(&coords_, self, coords);
}
@synthesize coords = coords_;
@synthesize coordsSize = coordsSize_;
- (IOSIntArray *)rules {
  return rules_;
}
- (void)setRules:(IOSIntArray *)rules {
  JreOperatorRetainedAssign(&rules_, self, rules);
}
@synthesize rules = rules_;
@synthesize rulesSize = rulesSize_;
- (IOSIntArray *)offsets {
  return offsets_;
}
- (void)setOffsets:(IOSIntArray *)offsets {
  JreOperatorRetainedAssign(&offsets_, self, offsets);
}
@synthesize offsets = offsets_;
@synthesize moveToCount = moveToCount_;
@synthesize isPolygonal_ = isPolygonal__;

- (id)init {
  if ((self = [super init])) {
    JreOperatorRetainedAssign(&coords_, self, [[[IOSDoubleArray alloc] initWithLength:20] autorelease]);
    coordsSize_ = 0;
    JreOperatorRetainedAssign(&rules_, self, [[[IOSIntArray alloc] initWithLength:10] autorelease]);
    rulesSize_ = 0;
    JreOperatorRetainedAssign(&offsets_, self, [[[IOSIntArray alloc] initWithLength:10] autorelease]);
    moveToCount_ = 0;
    isPolygonal__ = YES;
  }
  return self;
}

- (id)initWithPythagorasDIShape:(id<PythagorasDIShape>)s {
  if ((self = [super init])) {
    JreOperatorRetainedAssign(&coords_, self, [[[IOSDoubleArray alloc] initWithLength:20] autorelease]);
    coordsSize_ = 0;
    JreOperatorRetainedAssign(&rules_, self, [[[IOSIntArray alloc] initWithLength:10] autorelease]);
    rulesSize_ = 0;
    JreOperatorRetainedAssign(&offsets_, self, [[[IOSIntArray alloc] initWithLength:10] autorelease]);
    moveToCount_ = 0;
    isPolygonal__ = YES;
    IOSDoubleArray *segmentCoords = [[[IOSDoubleArray alloc] initWithLength:6] autorelease];
    double lastMoveX = 0.0f;
    double lastMoveY = 0.0f;
    int rulesIndex = 0;
    int coordsIndex = 0;
    for (id<PythagorasDPathIterator> pi = [((id<PythagorasDIShape>) NIL_CHK(s)) pathIteratorWithPythagorasDTransform:nil]; ![((id<PythagorasDPathIterator>) NIL_CHK(pi)) isDone]; [((id<PythagorasDPathIterator>) NIL_CHK(pi)) next]) {
      JreOperatorRetainedAssign(&coords_, self, [PythagorasDArea adjustSizeWithJavaLangDoubleArray:coords_ withInt:coordsIndex + 6]);
      JreOperatorRetainedAssign(&rules_, self, [PythagorasDArea adjustSizeWithJavaLangIntegerArray:rules_ withInt:rulesIndex + 1]);
      JreOperatorRetainedAssign(&offsets_, self, [PythagorasDArea adjustSizeWithJavaLangIntegerArray:offsets_ withInt:rulesIndex + 1]);
      [((IOSIntArray *) NIL_CHK(rules_)) replaceIntAtIndex:rulesIndex withInt:[((id<PythagorasDPathIterator>) NIL_CHK(pi)) currentSegmentWithJavaLangDoubleArray:segmentCoords]];
      [((IOSIntArray *) NIL_CHK(offsets_)) replaceIntAtIndex:rulesIndex withInt:coordsIndex];
      switch ([((IOSIntArray *) NIL_CHK(rules_)) intAtIndex:rulesIndex]) {
        case PythagorasDPathIterator_SEG_MOVETO:
        [((IOSDoubleArray *) NIL_CHK(coords_)) replaceDoubleAtIndex:coordsIndex++ withDouble:[((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:0]];
        [((IOSDoubleArray *) NIL_CHK(coords_)) replaceDoubleAtIndex:coordsIndex++ withDouble:[((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:1]];
        lastMoveX = [((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:0];
        lastMoveY = [((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:1];
        ++moveToCount_;
        break;
        case PythagorasDPathIterator_SEG_LINETO:
        if (([((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:0] != lastMoveX) || ([((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:1] != lastMoveY)) {
          [((IOSDoubleArray *) NIL_CHK(coords_)) replaceDoubleAtIndex:coordsIndex++ withDouble:[((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:0]];
          [((IOSDoubleArray *) NIL_CHK(coords_)) replaceDoubleAtIndex:coordsIndex++ withDouble:[((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:1]];
        }
        else {
          --rulesIndex;
        }
        break;
        case PythagorasDPathIterator_SEG_QUADTO:
        [JavaLangSystem arraycopyWithId:segmentCoords withInt:0 withId:coords_ withInt:coordsIndex withInt:4];
        coordsIndex += 4;
        isPolygonal__ = NO;
        break;
        case PythagorasDPathIterator_SEG_CUBICTO:
        [JavaLangSystem arraycopyWithId:segmentCoords withInt:0 withId:coords_ withInt:coordsIndex withInt:6];
        coordsIndex += 6;
        isPolygonal__ = NO;
        break;
        case PythagorasDPathIterator_SEG_CLOSE:
        break;
      }
      ++rulesIndex;
    }
    if ((rulesIndex != 0) && ([((IOSIntArray *) NIL_CHK(rules_)) intAtIndex:rulesIndex - 1] != PythagorasDPathIterator_SEG_CLOSE)) {
      [((IOSIntArray *) NIL_CHK(rules_)) replaceIntAtIndex:rulesIndex withInt:PythagorasDPathIterator_SEG_CLOSE];
      [((IOSIntArray *) NIL_CHK(offsets_)) replaceIntAtIndex:rulesIndex withInt:coordsSize_];
    }
    rulesSize_ = rulesIndex;
    coordsSize_ = coordsIndex;
  }
  return self;
}

- (BOOL)isPolygonal {
  return isPolygonal__;
}

- (BOOL)isRectangular {
  return (isPolygonal__) && (rulesSize_ <= 5) && (coordsSize_ <= 8) && ([((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:1] == [((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:3]) && ([((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:7] == [((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:5]) && ([((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:0] == [((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:6]) && ([((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:2] == [((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:4]);
}

- (BOOL)isSingular {
  return (moveToCount_ <= 1);
}

- (void)reset {
  coordsSize_ = 0;
  rulesSize_ = 0;
}

- (void)transformWithPythagorasDTransform:(id<PythagorasDTransform>)t {
  [self copy__WithPythagorasDArea:[[[PythagorasDArea alloc] initWithPythagorasDIShape:[PythagorasDTransforms createTransformedShapeWithPythagorasDTransform:t withPythagorasDIShape:self]] autorelease] withPythagorasDArea:self];
}

- (PythagorasDArea *)createTransformedAreaWithPythagorasDTransform:(id<PythagorasDTransform>)t {
  return [[[PythagorasDArea alloc] initWithPythagorasDIShape:[PythagorasDTransforms createTransformedShapeWithPythagorasDTransform:t withPythagorasDIShape:self]] autorelease];
}

- (void)addWithPythagorasDArea:(PythagorasDArea *)area {
  if (area == nil || [((PythagorasDArea *) NIL_CHK(area)) isEmpty]) {
    return;
  }
  else if ([self isEmpty]) {
    [self copy__WithPythagorasDArea:area withPythagorasDArea:self];
    return;
  }
  if ([self isPolygonal] && [((PythagorasDArea *) NIL_CHK(area)) isPolygonal]) {
    [self addPolygonWithPythagorasDArea:area];
  }
  else {
    [self addCurvePolygonWithPythagorasDArea:area];
  }
  if ([self areaBoundsSquare] < [PythagorasDGeometryUtil EPSILON]) {
    [self reset];
  }
}

- (void)intersectWithPythagorasDArea:(PythagorasDArea *)area {
  if (area == nil) {
    return;
  }
  else if ([self isEmpty] || [area isEmpty]) {
    [self reset];
    return;
  }
  if ([self isPolygonal] && [((PythagorasDArea *) NIL_CHK(area)) isPolygonal]) {
    [self intersectPolygonWithPythagorasDArea:area];
  }
  else {
    [self intersectCurvePolygonWithPythagorasDArea:area];
  }
  if ([self areaBoundsSquare] < [PythagorasDGeometryUtil EPSILON]) {
    [self reset];
  }
}

- (void)subtractWithPythagorasDArea:(PythagorasDArea *)area {
  if (area == nil || [self isEmpty] || [((PythagorasDArea *) NIL_CHK(area)) isEmpty]) {
    return;
  }
  if ([self isPolygonal] && [((PythagorasDArea *) NIL_CHK(area)) isPolygonal]) {
    [self subtractPolygonWithPythagorasDArea:area];
  }
  else {
    [self subtractCurvePolygonWithPythagorasDArea:area];
  }
  if ([self areaBoundsSquare] < [PythagorasDGeometryUtil EPSILON]) {
    [self reset];
  }
}

- (void)exclusiveOrWithPythagorasDArea:(PythagorasDArea *)area {
  PythagorasDArea *a = [self clone];
  [((PythagorasDArea *) NIL_CHK(a)) intersectWithPythagorasDArea:area];
  [self addWithPythagorasDArea:area];
  [self subtractWithPythagorasDArea:a];
}

- (BOOL)isEmpty {
  return (rulesSize_ == 0) && (coordsSize_ == 0);
}

- (BOOL)containsWithDouble:(double)x
                withDouble:(double)y {
  return ![self isEmpty] && [self containsExactWithDouble:x withDouble:y] > 0;
}

- (BOOL)containsWithDouble:(double)x
                withDouble:(double)y
                withDouble:(double)width
                withDouble:(double)height {
  int crossCount = [PythagorasDCrossing intersectPathWithPythagorasDPathIterator:[self pathIteratorWithPythagorasDTransform:nil] withDouble:x withDouble:y withDouble:width withDouble:height];
  return crossCount != PythagorasDCrossing_CROSSING && [PythagorasDCrossing isInsideEvenOddWithInt:crossCount];
}

- (BOOL)containsWithPythagorasDIPoint:(id<PythagorasDIPoint>)p {
  return [self containsWithDouble:[((id<PythagorasDIPoint>) NIL_CHK(p)) x] withDouble:[((id<PythagorasDIPoint>) NIL_CHK(p)) y]];
}

- (BOOL)containsWithPythagorasDIRectangle:(id<PythagorasDIRectangle>)r {
  return [self containsWithDouble:[((id<PythagorasDIRectangle>) NIL_CHK(r)) x] withDouble:[((id<PythagorasDIRectangle>) NIL_CHK(r)) y] withDouble:[((id<PythagorasDIRectangle>) NIL_CHK(r)) width] withDouble:[((id<PythagorasDIRectangle>) NIL_CHK(r)) height]];
}

- (BOOL)intersectsWithDouble:(double)x
                  withDouble:(double)y
                  withDouble:(double)width
                  withDouble:(double)height {
  if ((width <= 0.0f) || (height <= 0.0f)) {
    return NO;
  }
  else if (![[self bounds] intersectsWithDouble:x withDouble:y withDouble:width withDouble:height]) {
    return NO;
  }
  int crossCount = [PythagorasDCrossing intersectShapeWithPythagorasDIShape:self withDouble:x withDouble:y withDouble:width withDouble:height];
  return [PythagorasDCrossing isInsideEvenOddWithInt:crossCount];
}

- (BOOL)intersectsWithPythagorasDIRectangle:(id<PythagorasDIRectangle>)r {
  return [self intersectsWithDouble:[((id<PythagorasDIRectangle>) NIL_CHK(r)) x] withDouble:[((id<PythagorasDIRectangle>) NIL_CHK(r)) y] withDouble:[((id<PythagorasDIRectangle>) NIL_CHK(r)) width] withDouble:[((id<PythagorasDIRectangle>) NIL_CHK(r)) height]];
}

- (PythagorasDRectangle *)bounds {
  return [self boundsWithPythagorasDRectangle:[[[PythagorasDRectangle alloc] init] autorelease]];
}

- (PythagorasDRectangle *)boundsWithPythagorasDRectangle:(PythagorasDRectangle *)target {
  double maxX = [((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:0], maxY = [((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:1];
  double minX = [((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:0], minY = [((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:1];
  for (int i = 0; i < coordsSize_; ) {
    minX = [JavaLangMath minWithDouble:minX withDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:i]];
    maxX = [JavaLangMath maxWithDouble:maxX withDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:i++]];
    minY = [JavaLangMath minWithDouble:minY withDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:i]];
    maxY = [JavaLangMath maxWithDouble:maxY withDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:i++]];
  }
  return [[[PythagorasDRectangle alloc] initWithDouble:minX withDouble:minY withDouble:maxX - minX withDouble:maxY - minY] autorelease];
}

- (id<PythagorasDPathIterator>)pathIteratorWithPythagorasDTransform:(id<PythagorasDTransform>)t {
  return [[[PythagorasDArea_AreaPathIterator alloc] initWithPythagorasDArea:self withPythagorasDTransform:t] autorelease];
}

- (id<PythagorasDPathIterator>)pathIteratorWithPythagorasDTransform:(id<PythagorasDTransform>)t
                                                         withDouble:(double)flatness {
  return [[[PythagorasDFlatteningPathIterator alloc] initWithPythagorasDPathIterator:[self pathIteratorWithPythagorasDTransform:t] withDouble:flatness] autorelease];
}

- (BOOL)isEqual:(id)obj {
  if (self == obj) {
    return YES;
  }
  else if (!([obj isKindOfClass:[PythagorasDArea class]])) {
    return NO;
  }
  PythagorasDArea *area = [self clone];
  [((PythagorasDArea *) NIL_CHK(area)) subtractWithPythagorasDArea:(PythagorasDArea *) obj];
  return [((PythagorasDArea *) NIL_CHK(area)) isEmpty];
}

- (PythagorasDArea *)clone {
  PythagorasDArea *area = [[[PythagorasDArea alloc] init] autorelease];
  [self copy__WithPythagorasDArea:self withPythagorasDArea:area];
  return area;
}

- (void)addCurvePolygonWithPythagorasDArea:(PythagorasDArea *)area {
  PythagorasDCurveCrossingHelper *crossHelper = [[[PythagorasDCurveCrossingHelper alloc] initWithJavaLangDoubleArray:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasDArea *) NIL_CHK(area)).coords } count:2 type:[IOSClass classWithClass:[IOSDoubleArray class]]] withJavaLangIntegerArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasDArea *) NIL_CHK(area)).coordsSize } count:2] withJavaLangIntegerArray:[IOSObjectArray arrayWithObjects:(id[]){ rules_, ((PythagorasDArea *) NIL_CHK(area)).rules } count:2 type:[IOSClass classWithClass:[IOSIntArray class]]] withJavaLangIntegerArray:[IOSIntArray arrayWithInts:(int[]){ rulesSize_, ((PythagorasDArea *) NIL_CHK(area)).rulesSize } count:2] withJavaLangIntegerArray:[IOSObjectArray arrayWithObjects:(id[]){ offsets_, ((PythagorasDArea *) NIL_CHK(area)).offsets } count:2 type:[IOSClass classWithClass:[IOSIntArray class]]]] autorelease];
  IOSObjectArray *intersectPoints = [((PythagorasDCurveCrossingHelper *) NIL_CHK(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count] == 0) {
    if ([((PythagorasDArea *) NIL_CHK(area)) containsWithPythagorasDIRectangle:[self bounds]]) {
      [self copy__WithPythagorasDArea:area withPythagorasDArea:self];
    }
    else if (![self containsWithPythagorasDIRectangle:[((PythagorasDArea *) NIL_CHK(area)) bounds]]) {
      JreOperatorRetainedAssign(&coords_, self, [PythagorasDArea adjustSizeWithJavaLangDoubleArray:coords_ withInt:coordsSize_ + ((PythagorasDArea *) NIL_CHK(area)).coordsSize]);
      [JavaLangSystem arraycopyWithId:((PythagorasDArea *) NIL_CHK(area)).coords withInt:0 withId:coords_ withInt:coordsSize_ withInt:((PythagorasDArea *) NIL_CHK(area)).coordsSize];
      coordsSize_ += ((PythagorasDArea *) NIL_CHK(area)).coordsSize;
      JreOperatorRetainedAssign(&rules_, self, [PythagorasDArea adjustSizeWithJavaLangIntegerArray:rules_ withInt:rulesSize_ + ((PythagorasDArea *) NIL_CHK(area)).rulesSize]);
      [JavaLangSystem arraycopyWithId:((PythagorasDArea *) NIL_CHK(area)).rules withInt:0 withId:rules_ withInt:rulesSize_ withInt:((PythagorasDArea *) NIL_CHK(area)).rulesSize];
      rulesSize_ += ((PythagorasDArea *) NIL_CHK(area)).rulesSize;
      JreOperatorRetainedAssign(&offsets_, self, [PythagorasDArea adjustSizeWithJavaLangIntegerArray:offsets_ withInt:rulesSize_ + ((PythagorasDArea *) NIL_CHK(area)).rulesSize]);
      [JavaLangSystem arraycopyWithId:((PythagorasDArea *) NIL_CHK(area)).offsets withInt:0 withId:offsets_ withInt:rulesSize_ withInt:((PythagorasDArea *) NIL_CHK(area)).rulesSize];
    }
    return;
  }
  IOSDoubleArray *resultCoords = [[[IOSDoubleArray alloc] initWithLength:coordsSize_ + ((PythagorasDArea *) NIL_CHK(area)).coordsSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  IOSIntArray *resultRules = [[[IOSIntArray alloc] initWithLength:rulesSize_ + ((PythagorasDArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  IOSIntArray *resultOffsets = [[[IOSIntArray alloc] initWithLength:rulesSize_ + ((PythagorasDArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  PythagorasDIntersectPoint *point = ((PythagorasDIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]);
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasDPathIterator_SEG_MOVETO];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
  do {
    [((IOSDoubleArray *) NIL_CHK(resultCoords)) replaceDoubleAtIndex:resultCoordPos++ withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(point)) x]];
    [((IOSDoubleArray *) NIL_CHK(resultCoords)) replaceDoubleAtIndex:resultCoordPos++ withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(point)) y]];
    int curIndex = [((PythagorasDIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:YES];
    if (curIndex < 0) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasDArea *) NIL_CHK(area)) containsExactWithDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:2 * curIndex] withDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:2 * curIndex + 1]] > 0) {
      isCurrentArea = NO;
    }
    else {
      isCurrentArea = YES;
    }
    PythagorasDIntersectPoint *nextPoint = [self nextIntersectPointWithPythagorasDIntersectPointArray:intersectPoints withPythagorasDIntersectPoint:point withBOOL:isCurrentArea];
    IOSDoubleArray *coords = (isCurrentArea) ? self.coords : ((PythagorasDArea *) NIL_CHK(area)).coords;
    IOSIntArray *offsets = (isCurrentArea) ? self.offsets : ((PythagorasDArea *) NIL_CHK(area)).offsets;
    IOSIntArray *rules = (isCurrentArea) ? self.rules : ((PythagorasDArea *) NIL_CHK(area)).rules;
    int offset = [((PythagorasDIntersectPoint *) NIL_CHK(point)) ruleIndexWithBOOL:isCurrentArea];
    BOOL isCopyUntilZero = NO;
    if (([((PythagorasDIntersectPoint *) NIL_CHK(point)) ruleIndexWithBOOL:isCurrentArea] > [((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) ruleIndexWithBOOL:isCurrentArea])) {
      int rulesSize = (isCurrentArea) ? self.rulesSize : ((PythagorasDArea *) NIL_CHK(area)).rulesSize;
      resultCoordPos = [self includeCoordsAndRulesWithInt:offset + 1 withInt:rulesSize withJavaLangIntegerArray:rules withJavaLangIntegerArray:offsets withJavaLangIntegerArray:resultRules withJavaLangIntegerArray:resultOffsets withJavaLangDoubleArray:resultCoords withJavaLangDoubleArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasDIntersectPoint:point withBOOL:isCurrentArea withBOOL:NO withInt:0];
      resultRulesPos += rulesSize - offset - 1;
      offset = 1;
      isCopyUntilZero = YES;
    }
    int length = [((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) ruleIndexWithBOOL:isCurrentArea] - offset + 1;
    if (isCopyUntilZero) {
      offset = 0;
    }
    resultCoordPos = [self includeCoordsAndRulesWithInt:offset withInt:length withJavaLangIntegerArray:rules withJavaLangIntegerArray:offsets withJavaLangIntegerArray:resultRules withJavaLangIntegerArray:resultOffsets withJavaLangDoubleArray:resultCoords withJavaLangDoubleArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasDIntersectPoint:point withBOOL:isCurrentArea withBOOL:YES withInt:0];
    resultRulesPos += length - offset;
    point = nextPoint;
  }
  while (point != ((PythagorasDIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]));
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos++ withInt:PythagorasDPathIterator_SEG_CLOSE];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos - 1 withInt:resultCoordPos];
  self.coords = resultCoords;
  self.rules = resultRules;
  self.offsets = resultOffsets;
  self.coordsSize = resultCoordPos;
  self.rulesSize = resultRulesPos;
}

- (void)addPolygonWithPythagorasDArea:(PythagorasDArea *)area {
  PythagorasDCrossingHelper *crossHelper = [[[PythagorasDCrossingHelper alloc] initWithJavaLangDoubleArray:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasDArea *) NIL_CHK(area)).coords } count:2 type:[IOSClass classWithClass:[IOSDoubleArray class]]] withJavaLangIntegerArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasDArea *) NIL_CHK(area)).coordsSize } count:2]] autorelease];
  IOSObjectArray *intersectPoints = [((PythagorasDCrossingHelper *) NIL_CHK(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count] == 0) {
    if ([((PythagorasDArea *) NIL_CHK(area)) containsWithPythagorasDIRectangle:[self bounds]]) {
      [self copy__WithPythagorasDArea:area withPythagorasDArea:self];
    }
    else if (![self containsWithPythagorasDIRectangle:[((PythagorasDArea *) NIL_CHK(area)) bounds]]) {
      JreOperatorRetainedAssign(&coords_, self, [PythagorasDArea adjustSizeWithJavaLangDoubleArray:coords_ withInt:coordsSize_ + ((PythagorasDArea *) NIL_CHK(area)).coordsSize]);
      [JavaLangSystem arraycopyWithId:((PythagorasDArea *) NIL_CHK(area)).coords withInt:0 withId:coords_ withInt:coordsSize_ withInt:((PythagorasDArea *) NIL_CHK(area)).coordsSize];
      coordsSize_ += ((PythagorasDArea *) NIL_CHK(area)).coordsSize;
      JreOperatorRetainedAssign(&rules_, self, [PythagorasDArea adjustSizeWithJavaLangIntegerArray:rules_ withInt:rulesSize_ + ((PythagorasDArea *) NIL_CHK(area)).rulesSize]);
      [JavaLangSystem arraycopyWithId:((PythagorasDArea *) NIL_CHK(area)).rules withInt:0 withId:rules_ withInt:rulesSize_ withInt:((PythagorasDArea *) NIL_CHK(area)).rulesSize];
      rulesSize_ += ((PythagorasDArea *) NIL_CHK(area)).rulesSize;
      JreOperatorRetainedAssign(&offsets_, self, [PythagorasDArea adjustSizeWithJavaLangIntegerArray:offsets_ withInt:rulesSize_ + ((PythagorasDArea *) NIL_CHK(area)).rulesSize]);
      [JavaLangSystem arraycopyWithId:((PythagorasDArea *) NIL_CHK(area)).offsets withInt:0 withId:offsets_ withInt:rulesSize_ withInt:((PythagorasDArea *) NIL_CHK(area)).rulesSize];
    }
    return;
  }
  IOSDoubleArray *resultCoords = [[[IOSDoubleArray alloc] initWithLength:coordsSize_ + ((PythagorasDArea *) NIL_CHK(area)).coordsSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  IOSIntArray *resultRules = [[[IOSIntArray alloc] initWithLength:rulesSize_ + ((PythagorasDArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  IOSIntArray *resultOffsets = [[[IOSIntArray alloc] initWithLength:rulesSize_ + ((PythagorasDArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  PythagorasDIntersectPoint *point = ((PythagorasDIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]);
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasDPathIterator_SEG_MOVETO];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
  do {
    [((IOSDoubleArray *) NIL_CHK(resultCoords)) replaceDoubleAtIndex:resultCoordPos++ withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(point)) x]];
    [((IOSDoubleArray *) NIL_CHK(resultCoords)) replaceDoubleAtIndex:resultCoordPos++ withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(point)) y]];
    [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasDPathIterator_SEG_LINETO];
    [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos - 2];
    int curIndex = [((PythagorasDIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:YES];
    if (curIndex < 0) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasDArea *) NIL_CHK(area)) containsExactWithDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:2 * curIndex] withDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:2 * curIndex + 1]] > 0) {
      isCurrentArea = NO;
    }
    else {
      isCurrentArea = YES;
    }
    PythagorasDIntersectPoint *nextPoint = [self nextIntersectPointWithPythagorasDIntersectPointArray:intersectPoints withPythagorasDIntersectPoint:point withBOOL:isCurrentArea];
    IOSDoubleArray *coords = (isCurrentArea) ? self.coords : ((PythagorasDArea *) NIL_CHK(area)).coords;
    int offset = 2 * [((PythagorasDIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:isCurrentArea];
    if ((offset >= 0) && ([((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) begIndexWithBOOL:isCurrentArea] < [((PythagorasDIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:isCurrentArea])) {
      int coordSize = (isCurrentArea) ? self.coordsSize : ((PythagorasDArea *) NIL_CHK(area)).coordsSize;
      int length = coordSize - offset;
      [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      for (int i = 0; i < length / 2; i++) {
        [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasDPathIterator_SEG_LINETO];
        [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
        resultCoordPos += 2;
      }
      offset = 0;
    }
    if (offset >= 0) {
      int length = 2 * [((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) begIndexWithBOOL:isCurrentArea] - offset + 2;
      [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      for (int i = 0; i < length / 2; i++) {
        [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasDPathIterator_SEG_LINETO];
        [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
        resultCoordPos += 2;
      }
    }
    point = nextPoint;
  }
  while (point != ((PythagorasDIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]));
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos - 1 withInt:PythagorasDPathIterator_SEG_CLOSE];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos - 1 withInt:resultCoordPos];
  JreOperatorRetainedAssign(&coords_, self, resultCoords);
  JreOperatorRetainedAssign(&rules_, self, resultRules);
  JreOperatorRetainedAssign(&offsets_, self, resultOffsets);
  coordsSize_ = resultCoordPos;
  rulesSize_ = resultRulesPos;
}

- (void)intersectCurvePolygonWithPythagorasDArea:(PythagorasDArea *)area {
  PythagorasDCurveCrossingHelper *crossHelper = [[[PythagorasDCurveCrossingHelper alloc] initWithJavaLangDoubleArray:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasDArea *) NIL_CHK(area)).coords } count:2 type:[IOSClass classWithClass:[IOSDoubleArray class]]] withJavaLangIntegerArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasDArea *) NIL_CHK(area)).coordsSize } count:2] withJavaLangIntegerArray:[IOSObjectArray arrayWithObjects:(id[]){ rules_, ((PythagorasDArea *) NIL_CHK(area)).rules } count:2 type:[IOSClass classWithClass:[IOSIntArray class]]] withJavaLangIntegerArray:[IOSIntArray arrayWithInts:(int[]){ rulesSize_, ((PythagorasDArea *) NIL_CHK(area)).rulesSize } count:2] withJavaLangIntegerArray:[IOSObjectArray arrayWithObjects:(id[]){ offsets_, ((PythagorasDArea *) NIL_CHK(area)).offsets } count:2 type:[IOSClass classWithClass:[IOSIntArray class]]]] autorelease];
  IOSObjectArray *intersectPoints = [((PythagorasDCurveCrossingHelper *) NIL_CHK(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count] == 0) {
    if ([self containsWithPythagorasDIRectangle:[((PythagorasDArea *) NIL_CHK(area)) bounds]]) {
      [self copy__WithPythagorasDArea:area withPythagorasDArea:self];
    }
    else if (![((PythagorasDArea *) NIL_CHK(area)) containsWithPythagorasDIRectangle:[self bounds]]) {
      [self reset];
    }
    return;
  }
  IOSDoubleArray *resultCoords = [[[IOSDoubleArray alloc] initWithLength:coordsSize_ + ((PythagorasDArea *) NIL_CHK(area)).coordsSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  IOSIntArray *resultRules = [[[IOSIntArray alloc] initWithLength:rulesSize_ + ((PythagorasDArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  IOSIntArray *resultOffsets = [[[IOSIntArray alloc] initWithLength:rulesSize_ + ((PythagorasDArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  PythagorasDIntersectPoint *point = ((PythagorasDIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]);
  PythagorasDIntersectPoint *nextPoint = ((PythagorasDIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]);
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasDPathIterator_SEG_MOVETO];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
  do {
    [((IOSDoubleArray *) NIL_CHK(resultCoords)) replaceDoubleAtIndex:resultCoordPos++ withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(point)) x]];
    [((IOSDoubleArray *) NIL_CHK(resultCoords)) replaceDoubleAtIndex:resultCoordPos++ withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(point)) y]];
    int curIndex = [((PythagorasDIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:YES];
    if ((curIndex < 0) || ([((PythagorasDArea *) NIL_CHK(area)) containsExactWithDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:2 * curIndex] withDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:2 * curIndex + 1]] == 0)) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasDArea *) NIL_CHK(area)) containsExactWithDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:2 * curIndex] withDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:2 * curIndex + 1]] > 0) {
      isCurrentArea = YES;
    }
    else {
      isCurrentArea = NO;
    }
    nextPoint = [self nextIntersectPointWithPythagorasDIntersectPointArray:intersectPoints withPythagorasDIntersectPoint:point withBOOL:isCurrentArea];
    IOSDoubleArray *coords = (isCurrentArea) ? self.coords : ((PythagorasDArea *) NIL_CHK(area)).coords;
    IOSIntArray *offsets = (isCurrentArea) ? self.offsets : ((PythagorasDArea *) NIL_CHK(area)).offsets;
    IOSIntArray *rules = (isCurrentArea) ? self.rules : ((PythagorasDArea *) NIL_CHK(area)).rules;
    int offset = [((PythagorasDIntersectPoint *) NIL_CHK(point)) ruleIndexWithBOOL:isCurrentArea];
    BOOL isCopyUntilZero = NO;
    if ([((PythagorasDIntersectPoint *) NIL_CHK(point)) ruleIndexWithBOOL:isCurrentArea] > [((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) ruleIndexWithBOOL:isCurrentArea]) {
      int rulesSize = (isCurrentArea) ? self.rulesSize : ((PythagorasDArea *) NIL_CHK(area)).rulesSize;
      resultCoordPos = [self includeCoordsAndRulesWithInt:offset + 1 withInt:rulesSize withJavaLangIntegerArray:rules withJavaLangIntegerArray:offsets withJavaLangIntegerArray:resultRules withJavaLangIntegerArray:resultOffsets withJavaLangDoubleArray:resultCoords withJavaLangDoubleArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasDIntersectPoint:point withBOOL:isCurrentArea withBOOL:NO withInt:1];
      resultRulesPos += rulesSize - offset - 1;
      offset = 1;
      isCopyUntilZero = YES;
    }
    int length = [((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) ruleIndexWithBOOL:isCurrentArea] - offset + 1;
    if (isCopyUntilZero) {
      offset = 0;
      isCopyUntilZero = NO;
    }
    if ((length == offset) && ([((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) ruleWithBOOL:isCurrentArea] != PythagorasDPathIterator_SEG_LINETO) && ([((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) ruleWithBOOL:isCurrentArea] != PythagorasDPathIterator_SEG_CLOSE) && ([((PythagorasDIntersectPoint *) NIL_CHK(point)) ruleWithBOOL:isCurrentArea] != PythagorasDPathIterator_SEG_LINETO) && ([((PythagorasDIntersectPoint *) NIL_CHK(point)) ruleWithBOOL:isCurrentArea] != PythagorasDPathIterator_SEG_CLOSE)) {
      isCopyUntilZero = YES;
      length++;
    }
    resultCoordPos = [self includeCoordsAndRulesWithInt:offset withInt:length withJavaLangIntegerArray:rules withJavaLangIntegerArray:offsets withJavaLangIntegerArray:resultRules withJavaLangIntegerArray:resultOffsets withJavaLangDoubleArray:resultCoords withJavaLangDoubleArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasDIntersectPoint:nextPoint withBOOL:isCurrentArea withBOOL:YES withInt:1];
    resultRulesPos = ((length <= offset) || (isCopyUntilZero)) ? resultRulesPos + 1 : resultRulesPos + length;
    point = nextPoint;
  }
  while (point != ((PythagorasDIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]));
  if ([((IOSIntArray *) NIL_CHK(resultRules)) intAtIndex:resultRulesPos - 1] == PythagorasDPathIterator_SEG_LINETO) {
    [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos - 1 withInt:PythagorasDPathIterator_SEG_CLOSE];
  }
  else {
    [((IOSDoubleArray *) NIL_CHK(resultCoords)) replaceDoubleAtIndex:resultCoordPos++ withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) x]];
    [((IOSDoubleArray *) NIL_CHK(resultCoords)) replaceDoubleAtIndex:resultCoordPos++ withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) y]];
    [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos++ withInt:PythagorasDPathIterator_SEG_CLOSE];
  }
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos - 1 withInt:resultCoordPos];
  JreOperatorRetainedAssign(&coords_, self, resultCoords);
  JreOperatorRetainedAssign(&rules_, self, resultRules);
  JreOperatorRetainedAssign(&offsets_, self, resultOffsets);
  coordsSize_ = resultCoordPos;
  rulesSize_ = resultRulesPos;
}

- (void)intersectPolygonWithPythagorasDArea:(PythagorasDArea *)area {
  PythagorasDCrossingHelper *crossHelper = [[[PythagorasDCrossingHelper alloc] initWithJavaLangDoubleArray:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasDArea *) NIL_CHK(area)).coords } count:2 type:[IOSClass classWithClass:[IOSDoubleArray class]]] withJavaLangIntegerArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasDArea *) NIL_CHK(area)).coordsSize } count:2]] autorelease];
  IOSObjectArray *intersectPoints = [((PythagorasDCrossingHelper *) NIL_CHK(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count] == 0) {
    if ([self containsWithPythagorasDIRectangle:[((PythagorasDArea *) NIL_CHK(area)) bounds]]) {
      [self copy__WithPythagorasDArea:area withPythagorasDArea:self];
    }
    else if (![((PythagorasDArea *) NIL_CHK(area)) containsWithPythagorasDIRectangle:[self bounds]]) {
      [self reset];
    }
    return;
  }
  IOSDoubleArray *resultCoords = [[[IOSDoubleArray alloc] initWithLength:coordsSize_ + ((PythagorasDArea *) NIL_CHK(area)).coordsSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  IOSIntArray *resultRules = [[[IOSIntArray alloc] initWithLength:rulesSize_ + ((PythagorasDArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  IOSIntArray *resultOffsets = [[[IOSIntArray alloc] initWithLength:rulesSize_ + ((PythagorasDArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  PythagorasDIntersectPoint *point = ((PythagorasDIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]);
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasDPathIterator_SEG_MOVETO];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
  do {
    [((IOSDoubleArray *) NIL_CHK(resultCoords)) replaceDoubleAtIndex:resultCoordPos++ withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(point)) x]];
    [((IOSDoubleArray *) NIL_CHK(resultCoords)) replaceDoubleAtIndex:resultCoordPos++ withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(point)) y]];
    [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasDPathIterator_SEG_LINETO];
    [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos - 2];
    int curIndex = [((PythagorasDIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:YES];
    if ((curIndex < 0) || ([((PythagorasDArea *) NIL_CHK(area)) containsExactWithDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:2 * curIndex] withDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:2 * curIndex + 1]] == 0)) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasDArea *) NIL_CHK(area)) containsExactWithDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:2 * curIndex] withDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:2 * curIndex + 1]] > 0) {
      isCurrentArea = YES;
    }
    else {
      isCurrentArea = NO;
    }
    PythagorasDIntersectPoint *nextPoint = [self nextIntersectPointWithPythagorasDIntersectPointArray:intersectPoints withPythagorasDIntersectPoint:point withBOOL:isCurrentArea];
    IOSDoubleArray *coords = (isCurrentArea) ? self.coords : ((PythagorasDArea *) NIL_CHK(area)).coords;
    int offset = 2 * [((PythagorasDIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:isCurrentArea];
    if ((offset >= 0) && ([((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) begIndexWithBOOL:isCurrentArea] < [((PythagorasDIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:isCurrentArea])) {
      int coordSize = (isCurrentArea) ? self.coordsSize : ((PythagorasDArea *) NIL_CHK(area)).coordsSize;
      int length = coordSize - offset;
      [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      for (int i = 0; i < length / 2; i++) {
        [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasDPathIterator_SEG_LINETO];
        [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
        resultCoordPos += 2;
      }
      offset = 0;
    }
    if (offset >= 0) {
      int length = 2 * [((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) begIndexWithBOOL:isCurrentArea] - offset + 2;
      [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      for (int i = 0; i < length / 2; i++) {
        [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasDPathIterator_SEG_LINETO];
        [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
        resultCoordPos += 2;
      }
    }
    point = nextPoint;
  }
  while (point != ((PythagorasDIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]));
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos - 1 withInt:PythagorasDPathIterator_SEG_CLOSE];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos - 1 withInt:resultCoordPos];
  JreOperatorRetainedAssign(&coords_, self, resultCoords);
  JreOperatorRetainedAssign(&rules_, self, resultRules);
  JreOperatorRetainedAssign(&offsets_, self, resultOffsets);
  coordsSize_ = resultCoordPos;
  rulesSize_ = resultRulesPos;
}

- (void)subtractCurvePolygonWithPythagorasDArea:(PythagorasDArea *)area {
  PythagorasDCurveCrossingHelper *crossHelper = [[[PythagorasDCurveCrossingHelper alloc] initWithJavaLangDoubleArray:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasDArea *) NIL_CHK(area)).coords } count:2 type:[IOSClass classWithClass:[IOSDoubleArray class]]] withJavaLangIntegerArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasDArea *) NIL_CHK(area)).coordsSize } count:2] withJavaLangIntegerArray:[IOSObjectArray arrayWithObjects:(id[]){ rules_, ((PythagorasDArea *) NIL_CHK(area)).rules } count:2 type:[IOSClass classWithClass:[IOSIntArray class]]] withJavaLangIntegerArray:[IOSIntArray arrayWithInts:(int[]){ rulesSize_, ((PythagorasDArea *) NIL_CHK(area)).rulesSize } count:2] withJavaLangIntegerArray:[IOSObjectArray arrayWithObjects:(id[]){ offsets_, ((PythagorasDArea *) NIL_CHK(area)).offsets } count:2 type:[IOSClass classWithClass:[IOSIntArray class]]]] autorelease];
  IOSObjectArray *intersectPoints = [((PythagorasDCurveCrossingHelper *) NIL_CHK(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count] == 0 && [self containsWithPythagorasDIRectangle:[((PythagorasDArea *) NIL_CHK(area)) bounds]]) {
    [self copy__WithPythagorasDArea:area withPythagorasDArea:self];
    return;
  }
  IOSDoubleArray *resultCoords = [[[IOSDoubleArray alloc] initWithLength:coordsSize_ + ((PythagorasDArea *) NIL_CHK(area)).coordsSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  IOSIntArray *resultRules = [[[IOSIntArray alloc] initWithLength:rulesSize_ + ((PythagorasDArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  IOSIntArray *resultOffsets = [[[IOSIntArray alloc] initWithLength:rulesSize_ + ((PythagorasDArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]] autorelease];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  PythagorasDIntersectPoint *point = ((PythagorasDIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]);
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasDPathIterator_SEG_MOVETO];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
  do {
    [((IOSDoubleArray *) NIL_CHK(resultCoords)) replaceDoubleAtIndex:resultCoordPos++ withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(point)) x]];
    [((IOSDoubleArray *) NIL_CHK(resultCoords)) replaceDoubleAtIndex:resultCoordPos++ withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(point)) y]];
    int curIndex = [((IOSIntArray *) NIL_CHK(offsets_)) intAtIndex:[((PythagorasDIntersectPoint *) NIL_CHK(point)) ruleIndexWithBOOL:YES]] % coordsSize_;
    if ([((PythagorasDArea *) NIL_CHK(area)) containsExactWithDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:curIndex] withDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:curIndex + 1]] == 0) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasDArea *) NIL_CHK(area)) containsExactWithDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:curIndex] withDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:curIndex + 1]] > 0) {
      isCurrentArea = NO;
    }
    else {
      isCurrentArea = YES;
    }
    PythagorasDIntersectPoint *nextPoint = (isCurrentArea) ? [self nextIntersectPointWithPythagorasDIntersectPointArray:intersectPoints withPythagorasDIntersectPoint:point withBOOL:isCurrentArea] : [self prevIntersectPointWithPythagorasDIntersectPointArray:intersectPoints withPythagorasDIntersectPoint:point withBOOL:isCurrentArea];
    IOSDoubleArray *coords = (isCurrentArea) ? self.coords : ((PythagorasDArea *) NIL_CHK(area)).coords;
    IOSIntArray *offsets = (isCurrentArea) ? self.offsets : ((PythagorasDArea *) NIL_CHK(area)).offsets;
    IOSIntArray *rules = (isCurrentArea) ? self.rules : ((PythagorasDArea *) NIL_CHK(area)).rules;
    int offset = (isCurrentArea) ? [((PythagorasDIntersectPoint *) NIL_CHK(point)) ruleIndexWithBOOL:isCurrentArea] : [((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) ruleIndexWithBOOL:isCurrentArea];
    BOOL isCopyUntilZero = NO;
    if (((isCurrentArea) && ([((PythagorasDIntersectPoint *) NIL_CHK(point)) ruleIndexWithBOOL:isCurrentArea] > [((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) ruleIndexWithBOOL:isCurrentArea])) || ((!isCurrentArea) && ([((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) ruleIndexWithBOOL:isCurrentArea] > [((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) ruleIndexWithBOOL:isCurrentArea]))) {
      int rulesSize = (isCurrentArea) ? self.rulesSize : ((PythagorasDArea *) NIL_CHK(area)).rulesSize;
      resultCoordPos = [self includeCoordsAndRulesWithInt:offset + 1 withInt:rulesSize withJavaLangIntegerArray:rules withJavaLangIntegerArray:offsets withJavaLangIntegerArray:resultRules withJavaLangIntegerArray:resultOffsets withJavaLangDoubleArray:resultCoords withJavaLangDoubleArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasDIntersectPoint:point withBOOL:isCurrentArea withBOOL:NO withInt:2];
      resultRulesPos += rulesSize - offset - 1;
      offset = 1;
      isCopyUntilZero = YES;
    }
    int length = [((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) ruleIndexWithBOOL:isCurrentArea] - offset + 1;
    if (isCopyUntilZero) {
      offset = 0;
      isCopyUntilZero = NO;
    }
    resultCoordPos = [self includeCoordsAndRulesWithInt:offset withInt:length withJavaLangIntegerArray:rules withJavaLangIntegerArray:offsets withJavaLangIntegerArray:resultRules withJavaLangIntegerArray:resultOffsets withJavaLangDoubleArray:resultCoords withJavaLangDoubleArray:coords withInt:resultRulesPos withInt:resultCoordPos withPythagorasDIntersectPoint:point withBOOL:isCurrentArea withBOOL:YES withInt:2];
    if ((length == offset) && (([((IOSIntArray *) NIL_CHK(rules)) intAtIndex:offset] == PythagorasDPathIterator_SEG_QUADTO) || ([((IOSIntArray *) NIL_CHK(rules)) intAtIndex:offset] == PythagorasDPathIterator_SEG_CUBICTO))) {
      resultRulesPos++;
    }
    else {
      resultRulesPos = (length < offset || isCopyUntilZero) ? resultRulesPos + 1 : resultRulesPos + length - offset;
    }
    point = nextPoint;
  }
  while (point != ((PythagorasDIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]));
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos++ withInt:PythagorasDPathIterator_SEG_CLOSE];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos - 1 withInt:resultCoordPos];
  JreOperatorRetainedAssign(&coords_, self, resultCoords);
  JreOperatorRetainedAssign(&rules_, self, resultRules);
  JreOperatorRetainedAssign(&offsets_, self, resultOffsets);
  coordsSize_ = resultCoordPos;
  rulesSize_ = resultRulesPos;
}

- (void)subtractPolygonWithPythagorasDArea:(PythagorasDArea *)area {
  PythagorasDCrossingHelper *crossHelper = [[[PythagorasDCrossingHelper alloc] initWithJavaLangDoubleArray:[IOSObjectArray arrayWithObjects:(id[]){ coords_, ((PythagorasDArea *) NIL_CHK(area)).coords } count:2 type:[IOSClass classWithClass:[IOSDoubleArray class]]] withJavaLangIntegerArray:[IOSIntArray arrayWithInts:(int[]){ coordsSize_, ((PythagorasDArea *) NIL_CHK(area)).coordsSize } count:2]] autorelease];
  IOSObjectArray *intersectPoints = [((PythagorasDCrossingHelper *) NIL_CHK(crossHelper)) findCrossing];
  if ((int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count] == 0) {
    if ([self containsWithPythagorasDIRectangle:[((PythagorasDArea *) NIL_CHK(area)) bounds]]) {
      [self copy__WithPythagorasDArea:area withPythagorasDArea:self];
      return;
    }
    return;
  }
  IOSDoubleArray *resultCoords = [[[IOSDoubleArray alloc] initWithLength:2 * (coordsSize_ + ((PythagorasDArea *) NIL_CHK(area)).coordsSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count])] autorelease];
  IOSIntArray *resultRules = [[[IOSIntArray alloc] initWithLength:2 * (rulesSize_ + ((PythagorasDArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count])] autorelease];
  IOSIntArray *resultOffsets = [[[IOSIntArray alloc] initWithLength:2 * (rulesSize_ + ((PythagorasDArea *) NIL_CHK(area)).rulesSize + (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count])] autorelease];
  int resultCoordPos = 0;
  int resultRulesPos = 0;
  BOOL isCurrentArea = YES;
  int countPoints = 0;
  BOOL curArea = NO;
  BOOL addArea = NO;
  PythagorasDIntersectPoint *point = ((PythagorasDIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]);
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasDPathIterator_SEG_MOVETO];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
  do {
    [((IOSDoubleArray *) NIL_CHK(resultCoords)) replaceDoubleAtIndex:resultCoordPos++ withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(point)) x]];
    [((IOSDoubleArray *) NIL_CHK(resultCoords)) replaceDoubleAtIndex:resultCoordPos++ withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(point)) y]];
    [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasDPathIterator_SEG_LINETO];
    [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos - 2];
    int curIndex = [((PythagorasDIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:YES];
    if ((curIndex < 0) || ([((PythagorasDArea *) NIL_CHK(area)) isVertexWithDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:2 * curIndex] withDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:2 * curIndex + 1]] && [((PythagorasDCrossingHelper *) NIL_CHK(crossHelper)) containsPointWithJavaLangDoubleArray:[IOSDoubleArray arrayWithDoubles:(double[]){ [((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:2 * curIndex], [((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:2 * curIndex + 1] } count:2]] && ([((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:2 * curIndex] != [((PythagorasDIntersectPoint *) NIL_CHK(point)) x] || [((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:2 * curIndex + 1] != [((PythagorasDIntersectPoint *) NIL_CHK(point)) y]))) {
      isCurrentArea = !isCurrentArea;
    }
    else if ([((PythagorasDArea *) NIL_CHK(area)) containsExactWithDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:2 * curIndex] withDouble:[((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:2 * curIndex + 1]] > 0) {
      isCurrentArea = NO;
    }
    else {
      isCurrentArea = YES;
    }
    if (countPoints >= (int) [((IOSObjectArray *) NIL_CHK(intersectPoints)) count]) {
      isCurrentArea = !isCurrentArea;
    }
    if (isCurrentArea) {
      curArea = YES;
    }
    else {
      addArea = YES;
    }
    PythagorasDIntersectPoint *nextPoint = (isCurrentArea) ? [self nextIntersectPointWithPythagorasDIntersectPointArray:intersectPoints withPythagorasDIntersectPoint:point withBOOL:isCurrentArea] : [self prevIntersectPointWithPythagorasDIntersectPointArray:intersectPoints withPythagorasDIntersectPoint:point withBOOL:isCurrentArea];
    IOSDoubleArray *coords = (isCurrentArea) ? self.coords : ((PythagorasDArea *) NIL_CHK(area)).coords;
    int offset = (isCurrentArea) ? 2 * [((PythagorasDIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:isCurrentArea] : 2 * [((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) endIndexWithBOOL:isCurrentArea];
    if ((offset > 0) && (((isCurrentArea) && ([((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) begIndexWithBOOL:isCurrentArea] < [((PythagorasDIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:isCurrentArea])) || ((!isCurrentArea) && ([((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) endIndexWithBOOL:isCurrentArea] < [((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) begIndexWithBOOL:isCurrentArea])))) {
      int coordSize = (isCurrentArea) ? self.coordsSize : ((PythagorasDArea *) NIL_CHK(area)).coordsSize;
      int length = coordSize - offset;
      if (isCurrentArea) {
        [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      }
      else {
        IOSDoubleArray *temp = [[[IOSDoubleArray alloc] initWithLength:length] autorelease];
        [JavaLangSystem arraycopyWithId:coords withInt:offset withId:temp withInt:0 withInt:length];
        [self reverseCopyWithJavaLangDoubleArray:temp];
        [JavaLangSystem arraycopyWithId:temp withInt:0 withId:resultCoords withInt:resultCoordPos withInt:length];
      }
      for (int i = 0; i < length / 2; i++) {
        [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasDPathIterator_SEG_LINETO];
        [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
        resultCoordPos += 2;
      }
      offset = 0;
    }
    if (offset >= 0) {
      int length = (isCurrentArea) ? 2 * [((PythagorasDIntersectPoint *) NIL_CHK(nextPoint)) begIndexWithBOOL:isCurrentArea] - offset + 2 : 2 * [((PythagorasDIntersectPoint *) NIL_CHK(point)) begIndexWithBOOL:isCurrentArea] - offset + 2;
      if (isCurrentArea) {
        [JavaLangSystem arraycopyWithId:coords withInt:offset withId:resultCoords withInt:resultCoordPos withInt:length];
      }
      else {
        IOSDoubleArray *temp = [[[IOSDoubleArray alloc] initWithLength:length] autorelease];
        [JavaLangSystem arraycopyWithId:coords withInt:offset withId:temp withInt:0 withInt:length];
        [self reverseCopyWithJavaLangDoubleArray:temp];
        [JavaLangSystem arraycopyWithId:temp withInt:0 withId:resultCoords withInt:resultCoordPos withInt:length];
      }
      for (int i = 0; i < length / 2; i++) {
        [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasDPathIterator_SEG_LINETO];
        [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos];
        resultCoordPos += 2;
      }
    }
    point = nextPoint;
    countPoints++;
  }
  while (point != ((PythagorasDIntersectPoint *) [((IOSObjectArray *) NIL_CHK(intersectPoints)) objectAtIndex:0]) || !(curArea && addArea));
  [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos - 1 withInt:PythagorasDPathIterator_SEG_CLOSE];
  [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos - 1 withInt:resultCoordPos];
  JreOperatorRetainedAssign(&coords_, self, resultCoords);
  JreOperatorRetainedAssign(&rules_, self, resultRules);
  JreOperatorRetainedAssign(&offsets_, self, resultOffsets);
  coordsSize_ = resultCoordPos;
  rulesSize_ = resultRulesPos;
}

- (PythagorasDIntersectPoint *)nextIntersectPointWithPythagorasDIntersectPointArray:(IOSObjectArray *)iPoints
                                                      withPythagorasDIntersectPoint:(PythagorasDIntersectPoint *)isectPoint
                                                                           withBOOL:(BOOL)isCurrentArea {
  int endIndex = [((PythagorasDIntersectPoint *) NIL_CHK(isectPoint)) endIndexWithBOOL:isCurrentArea];
  if (endIndex < 0) {
    return ((PythagorasDIntersectPoint *) [((IOSObjectArray *) NIL_CHK(iPoints)) objectAtIndex:[JavaLangMath absWithInt:endIndex] - 1]);
  }
  PythagorasDIntersectPoint *firstIsectPoint = nil;
  PythagorasDIntersectPoint *nextIsectPoint = nil;
  {
    IOSObjectArray *a__ = iPoints;
    int n__ = (int) [((IOSObjectArray *) NIL_CHK(a__)) count];
    for (int i__ = 0; i__ < n__; i__++) {
      PythagorasDIntersectPoint *point = ((PythagorasDIntersectPoint *) [((IOSObjectArray *) NIL_CHK(a__)) objectAtIndex:i__]);
      int begIndex = [((PythagorasDIntersectPoint *) NIL_CHK(point)) begIndexWithBOOL:isCurrentArea];
      if (begIndex >= 0) {
        if (firstIsectPoint == nil) {
          firstIsectPoint = point;
        }
        else if (begIndex < [firstIsectPoint begIndexWithBOOL:isCurrentArea]) {
          firstIsectPoint = point;
        }
      }
      if (endIndex <= begIndex) {
        if (nextIsectPoint == nil) {
          nextIsectPoint = point;
        }
        else if (begIndex < [nextIsectPoint begIndexWithBOOL:isCurrentArea]) {
          nextIsectPoint = point;
        }
      }
    }
  }
  return (nextIsectPoint != nil) ? nextIsectPoint : firstIsectPoint;
}

- (PythagorasDIntersectPoint *)prevIntersectPointWithPythagorasDIntersectPointArray:(IOSObjectArray *)iPoints
                                                      withPythagorasDIntersectPoint:(PythagorasDIntersectPoint *)isectPoint
                                                                           withBOOL:(BOOL)isCurrentArea {
  int begIndex = [((PythagorasDIntersectPoint *) NIL_CHK(isectPoint)) begIndexWithBOOL:isCurrentArea];
  if (begIndex < 0) {
    return ((PythagorasDIntersectPoint *) [((IOSObjectArray *) NIL_CHK(iPoints)) objectAtIndex:[JavaLangMath absWithInt:begIndex] - 1]);
  }
  PythagorasDIntersectPoint *firstIsectPoint = nil;
  PythagorasDIntersectPoint *predIsectPoint = nil;
  {
    IOSObjectArray *a__ = iPoints;
    int n__ = (int) [((IOSObjectArray *) NIL_CHK(a__)) count];
    for (int i__ = 0; i__ < n__; i__++) {
      PythagorasDIntersectPoint *point = ((PythagorasDIntersectPoint *) [((IOSObjectArray *) NIL_CHK(a__)) objectAtIndex:i__]);
      int endIndex = [((PythagorasDIntersectPoint *) NIL_CHK(point)) endIndexWithBOOL:isCurrentArea];
      if (endIndex >= 0) {
        if (firstIsectPoint == nil) {
          firstIsectPoint = point;
        }
        else if (endIndex < [firstIsectPoint endIndexWithBOOL:isCurrentArea]) {
          firstIsectPoint = point;
        }
      }
      if (endIndex <= begIndex) {
        if (predIsectPoint == nil) {
          predIsectPoint = point;
        }
        else if (endIndex > [predIsectPoint endIndexWithBOOL:isCurrentArea]) {
          predIsectPoint = point;
        }
      }
    }
  }
  return (predIsectPoint != nil) ? predIsectPoint : firstIsectPoint;
}

- (int)includeCoordsAndRulesWithInt:(int)offset
                            withInt:(int)length
           withJavaLangIntegerArray:(IOSIntArray *)rules
           withJavaLangIntegerArray:(IOSIntArray *)offsets
           withJavaLangIntegerArray:(IOSIntArray *)resultRules
           withJavaLangIntegerArray:(IOSIntArray *)resultOffsets
            withJavaLangDoubleArray:(IOSDoubleArray *)resultCoords
            withJavaLangDoubleArray:(IOSDoubleArray *)coords
                            withInt:(int)resultRulesPos
                            withInt:(int)resultCoordPos
      withPythagorasDIntersectPoint:(PythagorasDIntersectPoint *)point
                           withBOOL:(BOOL)isCurrentArea
                           withBOOL:(BOOL)way
                            withInt:(int)operation {
  IOSDoubleArray *temp = [[[IOSDoubleArray alloc] initWithLength:8 * length] autorelease];
  int coordsCount = 0;
  BOOL isMoveIndex = YES;
  BOOL isMoveLength = YES;
  BOOL additional = NO;
  if (length <= offset) {
    for (int i = resultRulesPos; i < resultRulesPos + 1; i++) {
      [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:i withInt:PythagorasDPathIterator_SEG_LINETO];
    }
  }
  else {
    int j = resultRulesPos;
    for (int i = offset; i < length; i++) {
      [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:j++ withInt:PythagorasDPathIterator_SEG_LINETO];
    }
  }
  if ((length == offset) && (([((IOSIntArray *) NIL_CHK(rules)) intAtIndex:offset] == PythagorasDPathIterator_SEG_QUADTO) || ([((IOSIntArray *) NIL_CHK(rules)) intAtIndex:offset] == PythagorasDPathIterator_SEG_CUBICTO))) {
    length++;
    additional = YES;
  }
  for (int i = offset; i < length; i++) {
    int index = [((IOSIntArray *) NIL_CHK(offsets)) intAtIndex:i];
    if (!isMoveIndex) {
      index -= 2;
    }
    if (!isMoveLength) {
      length++;
      isMoveLength = YES;
    }
    {
      BOOL isLeft;
      IOSDoubleArray *coefs;
      switch ([((IOSIntArray *) NIL_CHK(rules)) intAtIndex:i]) {
        case PythagorasDPathIterator_SEG_MOVETO:
        isMoveIndex = NO;
        isMoveLength = NO;
        break;
        case PythagorasDPathIterator_SEG_LINETO:
        case PythagorasDPathIterator_SEG_CLOSE:
        [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasDPathIterator_SEG_LINETO];
        [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos + 2];
        isLeft = [PythagorasDCrossingHelper compareWithDouble:[((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index] withDouble:[((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index + 1] withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(point)) x] withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(point)) y]] > 0;
        if (way || !isLeft) {
          [((IOSDoubleArray *) NIL_CHK(temp)) replaceDoubleAtIndex:coordsCount++ withDouble:[((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index]];
          [((IOSDoubleArray *) NIL_CHK(temp)) replaceDoubleAtIndex:coordsCount++ withDouble:[((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index + 1]];
        }
        break;
        case PythagorasDPathIterator_SEG_QUADTO:
        [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasDPathIterator_SEG_QUADTO];
        [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos + 4];
        coefs = [IOSDoubleArray arrayWithDoubles:(double[]){ [((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index - 2], [((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index - 1], [((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index], [((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index + 1], [((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index + 2], [((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index + 3] } count:6];
        isLeft = [PythagorasDCrossingHelper compareWithDouble:[((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index - 2] withDouble:[((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index - 1] withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(point)) x] withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(point)) y]] > 0;
        if ((!additional) && (operation == 0 || operation == 2)) {
          isLeft = !isLeft;
          way = NO;
        }
        [PythagorasDGeometryUtil subQuadWithJavaLangDoubleArray:coefs withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(point)) paramWithBOOL:isCurrentArea] withBOOL:isLeft];
        if (way || isLeft) {
          [((IOSDoubleArray *) NIL_CHK(temp)) replaceDoubleAtIndex:coordsCount++ withDouble:[((IOSDoubleArray *) NIL_CHK(coefs)) doubleAtIndex:2]];
          [((IOSDoubleArray *) NIL_CHK(temp)) replaceDoubleAtIndex:coordsCount++ withDouble:[((IOSDoubleArray *) NIL_CHK(coefs)) doubleAtIndex:3]];
        }
        else {
          [JavaLangSystem arraycopyWithId:coefs withInt:2 withId:temp withInt:coordsCount withInt:4];
          coordsCount += 4;
        }
        break;
        case PythagorasDPathIterator_SEG_CUBICTO:
        [((IOSIntArray *) NIL_CHK(resultRules)) replaceIntAtIndex:resultRulesPos withInt:PythagorasDPathIterator_SEG_CUBICTO];
        [((IOSIntArray *) NIL_CHK(resultOffsets)) replaceIntAtIndex:resultRulesPos++ withInt:resultCoordPos + 6];
        coefs = [IOSDoubleArray arrayWithDoubles:(double[]){ [((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index - 2], [((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index - 1], [((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index], [((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index + 1], [((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index + 2], [((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index + 3], [((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index + 4], [((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index + 5] } count:8];
        isLeft = [PythagorasDCrossingHelper compareWithDouble:[((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index - 2] withDouble:[((IOSDoubleArray *) NIL_CHK(coords)) doubleAtIndex:index - 1] withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(point)) x] withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(point)) y]] > 0;
        [PythagorasDGeometryUtil subCubicWithJavaLangDoubleArray:coefs withDouble:[((PythagorasDIntersectPoint *) NIL_CHK(point)) paramWithBOOL:isCurrentArea] withBOOL:!isLeft];
        if (isLeft) {
          [JavaLangSystem arraycopyWithId:coefs withInt:2 withId:temp withInt:coordsCount withInt:6];
          coordsCount += 6;
        }
        else {
          [JavaLangSystem arraycopyWithId:coefs withInt:2 withId:temp withInt:coordsCount withInt:4];
          coordsCount += 4;
        }
        break;
      }
    }
  }
  if (operation == 2 && !isCurrentArea && coordsCount > 2) {
    [self reverseCopyWithJavaLangDoubleArray:temp];
    [JavaLangSystem arraycopyWithId:temp withInt:0 withId:resultCoords withInt:resultCoordPos withInt:coordsCount];
  }
  else {
    [JavaLangSystem arraycopyWithId:temp withInt:0 withId:resultCoords withInt:resultCoordPos withInt:coordsCount];
  }
  return (resultCoordPos + coordsCount);
}

- (void)copy__WithPythagorasDArea:(PythagorasDArea *)src
              withPythagorasDArea:(PythagorasDArea *)dst OBJC_METHOD_FAMILY_NONE {
  ((PythagorasDArea *) NIL_CHK(dst)).coordsSize = ((PythagorasDArea *) NIL_CHK(src)).coordsSize;
  ((PythagorasDArea *) NIL_CHK(dst)).coords = [PythagorasUtilPlatform cloneWithJavaLangDoubleArray:((PythagorasDArea *) NIL_CHK(src)).coords];
  ((PythagorasDArea *) NIL_CHK(dst)).rulesSize = ((PythagorasDArea *) NIL_CHK(src)).rulesSize;
  ((PythagorasDArea *) NIL_CHK(dst)).rules = [PythagorasUtilPlatform cloneWithJavaLangIntegerArray:((PythagorasDArea *) NIL_CHK(src)).rules];
  ((PythagorasDArea *) NIL_CHK(dst)).moveToCount = ((PythagorasDArea *) NIL_CHK(src)).moveToCount;
  ((PythagorasDArea *) NIL_CHK(dst)).offsets = [PythagorasUtilPlatform cloneWithJavaLangIntegerArray:((PythagorasDArea *) NIL_CHK(src)).offsets];
}

- (int)containsExactWithDouble:(double)x
                    withDouble:(double)y {
  id<PythagorasDPathIterator> pi = [self pathIteratorWithPythagorasDTransform:nil];
  int crossCount = [PythagorasDCrossing crossPathWithPythagorasDPathIterator:pi withDouble:x withDouble:y];
  if ([PythagorasDCrossing isInsideEvenOddWithInt:crossCount]) {
    return 1;
  }
  IOSDoubleArray *segmentCoords = [[[IOSDoubleArray alloc] initWithLength:6] autorelease];
  IOSDoubleArray *resultPoints = [[[IOSDoubleArray alloc] initWithLength:6] autorelease];
  int rule;
  double curX = -1;
  double curY = -1;
  double moveX = -1;
  double moveY = -1;
  for (pi = [self pathIteratorWithPythagorasDTransform:nil]; ![((id<PythagorasDPathIterator>) NIL_CHK(pi)) isDone]; [((id<PythagorasDPathIterator>) NIL_CHK(pi)) next]) {
    rule = [((id<PythagorasDPathIterator>) NIL_CHK(pi)) currentSegmentWithJavaLangDoubleArray:segmentCoords];
    switch (rule) {
      case PythagorasDPathIterator_SEG_MOVETO:
      moveX = curX = [((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:0];
      moveY = curY = [((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:1];
      break;
      case PythagorasDPathIterator_SEG_LINETO:
      if ([PythagorasDGeometryUtil intersectLinesWithDouble:curX withDouble:curY withDouble:[((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:1] withDouble:x withDouble:y withDouble:x withDouble:y withJavaLangDoubleArray:resultPoints] != 0) {
        return 0;
      }
      curX = [((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:0];
      curY = [((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:1];
      break;
      case PythagorasDPathIterator_SEG_QUADTO:
      if ([PythagorasDGeometryUtil intersectLineAndQuadWithDouble:x withDouble:y withDouble:x withDouble:y withDouble:curX withDouble:curY withDouble:[((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:3] withJavaLangDoubleArray:resultPoints] > 0) {
        return 0;
      }
      curX = [((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:2];
      curY = [((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:3];
      break;
      case PythagorasDPathIterator_SEG_CUBICTO:
      if ([PythagorasDGeometryUtil intersectLineAndCubicWithDouble:x withDouble:y withDouble:x withDouble:y withDouble:curX withDouble:curY withDouble:[((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:0] withDouble:[((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:1] withDouble:[((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:2] withDouble:[((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:3] withDouble:[((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:4] withDouble:[((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:5] withJavaLangDoubleArray:resultPoints] > 0) {
        return 0;
      }
      curX = [((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:4];
      curY = [((IOSDoubleArray *) NIL_CHK(segmentCoords)) doubleAtIndex:5];
      break;
      case PythagorasDPathIterator_SEG_CLOSE:
      if ([PythagorasDGeometryUtil intersectLinesWithDouble:curX withDouble:curY withDouble:moveX withDouble:moveY withDouble:x withDouble:y withDouble:x withDouble:y withJavaLangDoubleArray:resultPoints] != 0) {
        return 0;
      }
      curX = moveX;
      curY = moveY;
      break;
    }
  }
  return -1;
}

- (void)reverseCopyWithJavaLangDoubleArray:(IOSDoubleArray *)coords {
  IOSDoubleArray *temp = [[[IOSDoubleArray alloc] initWithLength:(int) [((IOSDoubleArray *) NIL_CHK(coords)) count]] autorelease];
  [JavaLangSystem arraycopyWithId:coords withInt:0 withId:temp withInt:0 withInt:(int) [((IOSDoubleArray *) NIL_CHK(coords)) count]];
  for (int i = 0; i < (int) [((IOSDoubleArray *) NIL_CHK(coords)) count]; ) {
    [((IOSDoubleArray *) NIL_CHK(coords)) replaceDoubleAtIndex:i withDouble:[((IOSDoubleArray *) NIL_CHK(temp)) doubleAtIndex:(int) [((IOSDoubleArray *) NIL_CHK(coords)) count] - i - 2]];
    [((IOSDoubleArray *) NIL_CHK(coords)) replaceDoubleAtIndex:i + 1 withDouble:[((IOSDoubleArray *) NIL_CHK(temp)) doubleAtIndex:(int) [((IOSDoubleArray *) NIL_CHK(coords)) count] - i - 1]];
    i = i + 2;
  }
}

- (double)areaBoundsSquare {
  PythagorasDRectangle *bounds = [self bounds];
  return [((PythagorasDRectangle *) NIL_CHK(bounds)) height] * [((PythagorasDRectangle *) NIL_CHK(bounds)) width];
}

- (BOOL)isVertexWithDouble:(double)x
                withDouble:(double)y {
  for (int i = 0; i < coordsSize_; ) {
    if (x == [((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:i++] && y == [((IOSDoubleArray *) NIL_CHK(coords_)) doubleAtIndex:i++]) {
      return YES;
    }
  }
  return NO;
}

+ (IOSDoubleArray *)adjustSizeWithJavaLangDoubleArray:(IOSDoubleArray *)array
                                              withInt:(int)newSize {
  if (newSize <= (int) [((IOSDoubleArray *) NIL_CHK(array)) count]) {
    return array;
  }
  IOSDoubleArray *newArray = [[[IOSDoubleArray alloc] initWithLength:2 * newSize] autorelease];
  [JavaLangSystem arraycopyWithId:array withInt:0 withId:newArray withInt:0 withInt:(int) [((IOSDoubleArray *) NIL_CHK(array)) count]];
  return newArray;
}

+ (IOSIntArray *)adjustSizeWithJavaLangIntegerArray:(IOSIntArray *)array
                                            withInt:(int)newSize {
  if (newSize <= (int) [((IOSIntArray *) NIL_CHK(array)) count]) {
    return array;
  }
  IOSIntArray *newArray = [[[IOSIntArray alloc] initWithLength:2 * newSize] autorelease];
  [JavaLangSystem arraycopyWithId:array withInt:0 withId:newArray withInt:0 withInt:(int) [((IOSIntArray *) NIL_CHK(array)) count]];
  return newArray;
}

- (id)copyWithZone:(NSZone *)zone {
  return [[self clone] retain];
}

- (void)dealloc {
  JreOperatorRetainedAssign(&offsets_, self, nil);
  JreOperatorRetainedAssign(&rules_, self, nil);
  JreOperatorRetainedAssign(&coords_, self, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  PythagorasDArea *typedCopy = (PythagorasDArea *) copy;
  typedCopy.coords = coords_;
  typedCopy.coordsSize = coordsSize_;
  typedCopy.rules = rules_;
  typedCopy.rulesSize = rulesSize_;
  typedCopy.offsets = offsets_;
  typedCopy.moveToCount = moveToCount_;
  typedCopy.isPolygonal_ = isPolygonal__;
}

@end
@implementation PythagorasDArea_AreaPathIterator

- (PythagorasDArea *)this$0 {
  return this$0_;
}
- (void)setThis$0:(PythagorasDArea *)this$0 {
  JreOperatorRetainedAssign(&this$0_, self, this$0);
}
@synthesize this$0 = this$0_;
- (id<PythagorasDTransform>)transform {
  return transform_;
}
- (void)setTransform:(id<PythagorasDTransform>)transform {
  JreOperatorRetainedAssign(&transform_, self, transform);
}
@synthesize transform = transform_;
@synthesize curRuleIndex = curRuleIndex_;
@synthesize curCoordIndex = curCoordIndex_;

- (id)initWithPythagorasDArea:(PythagorasDArea *)outer$
     withPythagorasDTransform:(id<PythagorasDTransform>)t {
  if ((self = [super init])) {
    JreOperatorRetainedAssign(&this$0_, self, outer$);
    curRuleIndex_ = 0;
    curCoordIndex_ = 0;
    self.transform = t;
  }
  return self;
}

- (int)windingRule {
  return PythagorasDPathIterator_WIND_EVEN_ODD;
}

- (BOOL)isDone {
  return curRuleIndex_ >= this$0_.rulesSize;
}

- (void)next {
  switch ([((IOSIntArray *) NIL_CHK(this$0_.rules)) intAtIndex:curRuleIndex_]) {
    case PythagorasDPathIterator_SEG_MOVETO:
    case PythagorasDPathIterator_SEG_LINETO:
    curCoordIndex_ += 2;
    break;
    case PythagorasDPathIterator_SEG_QUADTO:
    curCoordIndex_ += 4;
    break;
    case PythagorasDPathIterator_SEG_CUBICTO:
    curCoordIndex_ += 6;
    break;
  }
  curRuleIndex_++;
}

- (int)currentSegmentWithJavaLangDoubleArray:(IOSDoubleArray *)c {
  if ([self isDone]) {
    @throw [[[JavaUtilNoSuchElementException alloc] initWithNSString:@"Iterator out of bounds"] autorelease];
  }
  int count = 0;
  switch ([((IOSIntArray *) NIL_CHK(this$0_.rules)) intAtIndex:curRuleIndex_]) {
    case PythagorasDPathIterator_SEG_CUBICTO:
    [((IOSDoubleArray *) NIL_CHK(c)) replaceDoubleAtIndex:4 withDouble:[((IOSDoubleArray *) NIL_CHK(this$0_.coords)) doubleAtIndex:curCoordIndex_ + 4]];
    [((IOSDoubleArray *) NIL_CHK(c)) replaceDoubleAtIndex:5 withDouble:[((IOSDoubleArray *) NIL_CHK(this$0_.coords)) doubleAtIndex:curCoordIndex_ + 5]];
    count = 1;
    case PythagorasDPathIterator_SEG_QUADTO:
    [((IOSDoubleArray *) NIL_CHK(c)) replaceDoubleAtIndex:2 withDouble:[((IOSDoubleArray *) NIL_CHK(this$0_.coords)) doubleAtIndex:curCoordIndex_ + 2]];
    [((IOSDoubleArray *) NIL_CHK(c)) replaceDoubleAtIndex:3 withDouble:[((IOSDoubleArray *) NIL_CHK(this$0_.coords)) doubleAtIndex:curCoordIndex_ + 3]];
    count += 1;
    case PythagorasDPathIterator_SEG_MOVETO:
    case PythagorasDPathIterator_SEG_LINETO:
    [((IOSDoubleArray *) NIL_CHK(c)) replaceDoubleAtIndex:0 withDouble:[((IOSDoubleArray *) NIL_CHK(this$0_.coords)) doubleAtIndex:curCoordIndex_]];
    [((IOSDoubleArray *) NIL_CHK(c)) replaceDoubleAtIndex:1 withDouble:[((IOSDoubleArray *) NIL_CHK(this$0_.coords)) doubleAtIndex:curCoordIndex_ + 1]];
    count += 1;
  }
  if (transform_ != nil) {
    [transform_ transformWithJavaLangDoubleArray:c withInt:0 withJavaLangDoubleArray:c withInt:0 withInt:count];
  }
  return [((IOSIntArray *) NIL_CHK(this$0_.rules)) intAtIndex:curRuleIndex_];
}

- (void)dealloc {
  JreOperatorRetainedAssign(&transform_, self, nil);
  JreOperatorRetainedAssign(&this$0_, self, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  PythagorasDArea_AreaPathIterator *typedCopy = (PythagorasDArea_AreaPathIterator *) copy;
  typedCopy.this$0 = this$0_;
  typedCopy.transform = transform_;
  typedCopy.curRuleIndex = curRuleIndex_;
  typedCopy.curCoordIndex = curCoordIndex_;
}

@end
