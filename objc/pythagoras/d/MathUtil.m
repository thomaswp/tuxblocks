//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: pythagoras/d/MathUtil.java
//
//  Created by Thomas on 7/9/13.
//

#import "java/lang/IllegalArgumentException.h"
#import "java/lang/Integer.h"
#import "java/lang/Math.h"
#import "java/lang/StringBuilder.h"

@implementation PythagorasDMathUtil

static int PythagorasDMathUtil_TO_STRING_DECIMAL_PLACES_;

+ (double)EPSILON {
  return PythagorasDMathUtil_EPSILON;
}

+ (double)TAU {
  return PythagorasDMathUtil_TAU;
}

+ (double)TWO_PI {
  return PythagorasDMathUtil_TWO_PI;
}

+ (double)HALF_PI {
  return PythagorasDMathUtil_HALF_PI;
}

+ (int)TO_STRING_DECIMAL_PLACES {
  return PythagorasDMathUtil_TO_STRING_DECIMAL_PLACES_;
}

+ (int *)TO_STRING_DECIMAL_PLACESRef {
  return &PythagorasDMathUtil_TO_STRING_DECIMAL_PLACES_;
}

+ (int)roundWithDouble:(double)v {
  return (v < 0.0f) ? (int) (v - 0.5f) : (int) (v + 0.5f);
}

+ (int)ifloorWithDouble:(double)v {
  int iv = (int) v;
  return (v >= 0.0f || iv == v || iv == JavaLangInteger_MIN_VALUE) ? iv : (iv - 1);
}

+ (int)iceilWithDouble:(double)v {
  int iv = (int) v;
  return (v <= 0.0f || iv == v || iv == JavaLangInteger_MAX_VALUE) ? iv : (iv + 1);
}

+ (double)clampWithDouble:(double)v
               withDouble:(double)lower
               withDouble:(double)upper {
  if (v < lower) return lower;
  else if (v > upper) return upper;
  else return v;
}

+ (double)roundNearestWithDouble:(double)v
                      withDouble:(double)target {
  target = [JavaLangMath absWithDouble:target];
  if (v >= 0) {
    return target * [JavaLangMath floorWithDouble:(v + 0.5f * target) / target];
  }
  else {
    return target * [JavaLangMath ceilWithDouble:(v - 0.5f * target) / target];
  }
}

+ (BOOL)isWithinWithDouble:(double)v
                withDouble:(double)lower
                withDouble:(double)upper {
  return v >= lower && v <= upper;
}

+ (double)normalWithDouble:(double)normal
                withDouble:(double)mean
                withDouble:(double)stddev {
  return stddev * normal + mean;
}

+ (double)exponentialWithDouble:(double)random
                     withDouble:(double)mean {
  return -[JavaLangMath logWithDouble:1.0f - random] * mean;
}

+ (double)lerpaWithDouble:(double)a1
               withDouble:(double)a2
               withDouble:(double)t {
  double ma1 = [PythagorasDMathUtil mirrorAngleWithDouble:a1], ma2 = [PythagorasDMathUtil mirrorAngleWithDouble:a2];
  double d = [JavaLangMath absWithDouble:a2 - a1], md = [JavaLangMath absWithDouble:ma1 - ma2];
  return (d < md) ? [PythagorasDMathUtil lerpWithDouble:a1 withDouble:a2 withDouble:t] : [PythagorasDMathUtil mirrorAngleWithDouble:[PythagorasDMathUtil lerpWithDouble:ma1 withDouble:ma2 withDouble:t]];
}

+ (double)lerpWithDouble:(double)v1
              withDouble:(double)v2
              withDouble:(double)t {
  return v1 + t * (v2 - v1);
}

+ (BOOL)epsilonEqualsWithDouble:(double)v1
                     withDouble:(double)v2 {
  return [JavaLangMath absWithDouble:v1 - v2] < PythagorasDMathUtil_EPSILON;
}

+ (double)angularDistanceWithDouble:(double)a1
                         withDouble:(double)a2 {
  double ma1 = [PythagorasDMathUtil mirrorAngleWithDouble:a1], ma2 = [PythagorasDMathUtil mirrorAngleWithDouble:a2];
  return [JavaLangMath minWithDouble:[JavaLangMath absWithDouble:a1 - a2] withDouble:[JavaLangMath absWithDouble:ma1 - ma2]];
}

+ (double)angularDifferenceWithDouble:(double)a1
                           withDouble:(double)a2 {
  double ma1 = [PythagorasDMathUtil mirrorAngleWithDouble:a1], ma2 = [PythagorasDMathUtil mirrorAngleWithDouble:a2];
  double diff = a1 - a2, mdiff = ma2 - ma1;
  return ([JavaLangMath absWithDouble:diff] < [JavaLangMath absWithDouble:mdiff]) ? diff : mdiff;
}

+ (double)normalizeAngleWithDouble:(double)a {
  while (a < -JavaLangMath_PI) {
    a += PythagorasDMathUtil_TWO_PI;
  }
  while (a >= JavaLangMath_PI) {
    a -= PythagorasDMathUtil_TWO_PI;
  }
  return a;
}

+ (double)normalizeAnglePositiveWithDouble:(double)a {
  while (a < 0.0f) {
    a += PythagorasDMathUtil_TWO_PI;
  }
  while (a >= PythagorasDMathUtil_TWO_PI) {
    a -= PythagorasDMathUtil_TWO_PI;
  }
  return a;
}

+ (double)mirrorAngleWithDouble:(double)a {
  return (a > 0.0f ? JavaLangMath_PI : -JavaLangMath_PI) - a;
}

+ (void)setToStringDecimalPlacesWithInt:(int)places {
  if (places < 0) @throw [[[JavaLangIllegalArgumentException alloc] initWithNSString:@"Decimal places must be >= 0."] autorelease];
  PythagorasDMathUtil_TO_STRING_DECIMAL_PLACES_ = places;
}

+ (NSString *)toStringWithDouble:(double)value {
  return [PythagorasDMathUtil toStringWithDouble:value withInt:PythagorasDMathUtil_TO_STRING_DECIMAL_PLACES_];
}

+ (NSString *)toStringWithDouble:(double)value
                         withInt:(int)decimalPlaces {
  JavaLangStringBuilder *buf = [[[JavaLangStringBuilder alloc] init] autorelease];
  if (value >= 0) (void) [((JavaLangStringBuilder *) NIL_CHK(buf)) appendWithNSString:@"+"];
  else {
    (void) [((JavaLangStringBuilder *) NIL_CHK(buf)) appendWithNSString:@"-"];
    value = -value;
  }
  int ivalue = (int) value;
  (void) [((JavaLangStringBuilder *) NIL_CHK(buf)) appendWithInt:ivalue];
  if (decimalPlaces > 0) {
    (void) [((JavaLangStringBuilder *) NIL_CHK(buf)) appendWithNSString:@"."];
    for (int ii = 0; ii < decimalPlaces; ii++) {
      value = (value - ivalue) * 10;
      ivalue = (int) value;
      (void) [((JavaLangStringBuilder *) NIL_CHK(buf)) appendWithInt:ivalue];
    }
    for (int ii = 0; ii < decimalPlaces - 1; ii++) {
      if ([((JavaLangStringBuilder *) NIL_CHK(buf)) charAtWithInt:[((JavaLangStringBuilder *) NIL_CHK(buf)) sequenceLength] - 1] == '0') {
        [((JavaLangStringBuilder *) NIL_CHK(buf)) setLengthWithInt:[((JavaLangStringBuilder *) NIL_CHK(buf)) sequenceLength] - 1];
      }
    }
  }
  return [((JavaLangStringBuilder *) NIL_CHK(buf)) description];
}

- (id)init {
  return [super init];
}

+ (void)initialize {
  if (self == [PythagorasDMathUtil class]) {
    PythagorasDMathUtil_TO_STRING_DECIMAL_PLACES_ = 3;
  }
}

- (void)dealloc {
  [super dealloc];
}

@end
