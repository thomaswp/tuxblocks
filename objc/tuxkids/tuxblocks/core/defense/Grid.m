//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: C:\Users\Thomas\Documents\Eclipse\Tux\tuxblocks\core\src\main\java\tuxkids\tuxblocks\core\defense\Grid.java
//
//  Created by Thomas on 7/1/13.
//

#import "IOSBooleanArray.h"
#import "IOSObjectArray.h"
#import "java/lang/Boolean.h"
#import "java/lang/Float.h"
#import "java/lang/Math.h"
#import "java/util/ArrayList.h"
#import "java/util/HashMap.h"
#import "java/util/Iterator.h"
#import "java/util/List.h"
#import "playn/core/Canvas.h"
#import "playn/core/CanvasImage.h"
#import "playn/core/Graphics.h"
#import "playn/core/GroupLayer.h"
#import "playn/core/Image.h"
#import "playn/core/ImageLayer.h"
#import "playn/core/Layer.h"
#import "playn/core/Platform.h"
#import "playn/core/PlayN.h"
#import "playn/core/Touch.h"
#import "playn/core/util/Clock.h"
#import "pythagoras/f/Vector.h"
#import "pythagoras/i/Point.h"
#import "tripleplay/particle/Emitter.h"
#import "tripleplay/particle/Particles.h"
#import "tripleplay/particle/TuxParticles.h"
#import "tripleplay/util/Colors.h"
#import "tuxkids/tuxblocks/core/GameState.h"
#import "tuxkids/tuxblocks/core/ImageLayerTintable.h"
#import "tuxkids/tuxblocks/core/PlayNObject.h"
#import "tuxkids/tuxblocks/core/defense/Grid.h"
#import "tuxkids/tuxblocks/core/defense/GridObject.h"
#import "tuxkids/tuxblocks/core/defense/Pathing.h"
#import "tuxkids/tuxblocks/core/defense/projectile/ChainProjectile.h"
#import "tuxkids/tuxblocks/core/defense/projectile/Projectile.h"
#import "tuxkids/tuxblocks/core/defense/round/Level.h"
#import "tuxkids/tuxblocks/core/defense/round/Round.h"
#import "tuxkids/tuxblocks/core/defense/tower/Tower.h"
#import "tuxkids/tuxblocks/core/defense/walker/Walker.h"
#import "tuxkids/tuxblocks/core/effect/Effect.h"
#import "tuxkids/tuxblocks/core/utils/MultiList.h"

@implementation TBDGrid

@synthesize cellSize_ = cellSize__;
@synthesize rows_ = rows__;
@synthesize cols_ = cols__;
- (id<PlaynCoreGroupLayer>)layer_ {
  return layer__;
}
- (void)setLayer_:(id<PlaynCoreGroupLayer>)layer_ {
  JreOperatorRetainedAssign(&layer__, self, layer_);
}
@synthesize layer_ = layer__;
- (id<PlaynCoreGroupLayer>)gridLayer {
  return gridLayer_;
}
- (void)setGridLayer:(id<PlaynCoreGroupLayer>)gridLayer {
  JreOperatorRetainedAssign(&gridLayer_, self, gridLayer);
}
@synthesize gridLayer = gridLayer_;
- (id<PlaynCoreGroupLayer>)overlayLayer {
  return overlayLayer_;
}
- (void)setOverlayLayer:(id<PlaynCoreGroupLayer>)overlayLayer {
  JreOperatorRetainedAssign(&overlayLayer_, self, overlayLayer);
}
@synthesize overlayLayer = overlayLayer_;
- (id<PlaynCoreImageLayer>)gridSprite {
  return gridSprite_;
}
- (void)setGridSprite:(id<PlaynCoreImageLayer>)gridSprite {
  JreOperatorRetainedAssign(&gridSprite_, self, gridSprite);
}
@synthesize gridSprite = gridSprite_;
- (IOSObjectArray *)passability {
  return passability_;
}
- (void)setPassability:(IOSObjectArray *)passability {
  JreOperatorRetainedAssign(&passability_, self, passability);
}
@synthesize passability = passability_;
- (id<JavaUtilList>)walkers {
  return walkers_;
}
- (void)setWalkers:(id<JavaUtilList>)walkers {
  JreOperatorRetainedAssign(&walkers_, self, walkers);
}
@synthesize walkers = walkers_;
- (id<JavaUtilList>)projectiles {
  return projectiles_;
}
- (void)setProjectiles:(id<JavaUtilList>)projectiles {
  JreOperatorRetainedAssign(&projectiles_, self, projectiles);
}
@synthesize projectiles = projectiles_;
- (id<JavaUtilList>)towers {
  return towers_;
}
- (void)setTowers:(id<JavaUtilList>)towers {
  JreOperatorRetainedAssign(&towers_, self, towers);
}
@synthesize towers = towers_;
- (id<JavaUtilList>)effects {
  return effects_;
}
- (void)setEffects:(id<JavaUtilList>)effects {
  JreOperatorRetainedAssign(&effects_, self, effects);
}
@synthesize effects = effects_;
- (TBMultiList *)gridObjects {
  return gridObjects_;
}
- (void)setGridObjects:(TBMultiList *)gridObjects {
  JreOperatorRetainedAssign(&gridObjects_, self, gridObjects);
}
@synthesize gridObjects = gridObjects_;
- (PythagorasIPoint *)walkerStart {
  return walkerStart_;
}
- (void)setWalkerStart:(PythagorasIPoint *)walkerStart {
  JreOperatorRetainedAssign(&walkerStart_, self, walkerStart);
}
@synthesize walkerStart = walkerStart_;
- (PythagorasIPoint *)walkerDestination {
  return walkerDestination_;
}
- (void)setWalkerDestination:(PythagorasIPoint *)walkerDestination {
  JreOperatorRetainedAssign(&walkerDestination_, self, walkerDestination);
}
@synthesize walkerDestination = walkerDestination_;
- (TBTower *)toPlace {
  return toPlace_;
}
- (void)setToPlace:(TBTower *)toPlace {
  JreOperatorRetainedAssign(&toPlace_, self, toPlace);
}
@synthesize toPlace = toPlace_;
- (id<PlaynCoreImageLayer>)toPlaceRadius {
  return toPlaceRadius_;
}
- (void)setToPlaceRadius:(id<PlaynCoreImageLayer>)toPlaceRadius {
  JreOperatorRetainedAssign(&toPlaceRadius_, self, toPlaceRadius);
}
@synthesize toPlaceRadius = toPlaceRadius_;
- (id<JavaUtilList>)currentPath_ {
  return currentPath__;
}
- (void)setCurrentPath_:(id<JavaUtilList>)currentPath_ {
  JreOperatorRetainedAssign(&currentPath__, self, currentPath_);
}
@synthesize currentPath_ = currentPath__;
- (TBLevel *)level_ {
  return level__;
}
- (void)setLevel_:(TBLevel *)level_ {
  JreOperatorRetainedAssign(&level__, self, level_);
}
@synthesize level_ = level__;
@synthesize targetAlpha = targetAlpha_;
@synthesize towerColor_ = towerColor__;
- (TPParticles *)particles_ {
  return particles__;
}
- (void)setParticles_:(TPParticles *)particles_ {
  JreOperatorRetainedAssign(&particles__, self, particles_);
}
@synthesize particles_ = particles__;
- (TBGameState *)state {
  return state_;
}
- (void)setState:(TBGameState *)state {
  JreOperatorRetainedAssign(&state_, self, state);
}
@synthesize state = state_;
- (JavaUtilHashMap *)validPlacementMap {
  return validPlacementMap_;
}
- (void)setValidPlacementMap:(JavaUtilHashMap *)validPlacementMap {
  JreOperatorRetainedAssign(&validPlacementMap_, self, validPlacementMap);
}
@synthesize validPlacementMap = validPlacementMap_;

- (TPParticles *)particles {
  return particles__;
}

- (TBLevel *)level {
  return level__;
}

- (int)towerColor {
  return towerColor__;
}

- (int)width {
  return cols__ * cellSize__;
}

- (int)height {
  return rows__ * cellSize__;
}

- (int)rows {
  return rows__;
}

- (int)cols {
  return cols__;
}

- (id<JavaUtilList>)currentPath {
  return currentPath__;
}

- (id<PlaynCoreGroupLayer>)layer {
  return layer__;
}

- (IOSObjectArray *)getPassability {
  return passability_;
}

- (float)cellSize {
  return cellSize__;
}

- (void)setTowerColorWithInt:(int)themeColor {
  self.towerColor_ = themeColor;
}

- (id)initWithTBGameState:(TBGameState *)gameState
                  withInt:(int)rows
                  withInt:(int)cols
                  withInt:(int)maxWidth
                  withInt:(int)maxHeight {
  if ((self = [super init])) {
    JreOperatorRetainedAssign(&walkers_, self, [[[JavaUtilArrayList alloc] init] autorelease]);
    JreOperatorRetainedAssign(&projectiles_, self, [[[JavaUtilArrayList alloc] init] autorelease]);
    JreOperatorRetainedAssign(&towers_, self, [[[JavaUtilArrayList alloc] init] autorelease]);
    JreOperatorRetainedAssign(&effects_, self, [[[JavaUtilArrayList alloc] init] autorelease]);
    JreOperatorRetainedAssign(&gridObjects_, self, [[[TBMultiList alloc] initWithJavaUtilListArray:[IOSObjectArray arrayWithType:[IOSClass classWithProtocol:@protocol(JavaUtilList)] count:4, walkers_, projectiles_, towers_, effects_ ]] autorelease]);
    targetAlpha_ = 1;
    JreOperatorRetainedAssign(&validPlacementMap_, self, [[[JavaUtilHashMap alloc] init] autorelease]);
    self.state = gameState;
    self.rows_ = rows;
    self.cols_ = cols;
    JreOperatorRetainedAssign(&passability_, self, [IOSObjectArray arrayWithObjects:(id[]){ [[IOSBooleanArray alloc] initWithLength:cols] } count:rows type:[IOSClass classWithClass:[IOSBooleanArray class]]]);
    for (int i = 0; i < rows; i++) {
      for (int j = 0; j < cols; j++) {
        [((IOSBooleanArray *) [((IOSObjectArray *) NIL_CHK(passability_)) objectAtIndex:i]) replaceBooleanAtIndex:j withBoolean:YES];
      }
    }
    int maxRowSize = maxHeight / rows, maxColSize = maxWidth / cols;
    cellSize__ = [JavaLangMath minWithInt:maxRowSize withInt:maxColSize];
    JreOperatorRetainedAssign(&layer__, self, [((id<PlaynCoreGraphics>) [TBPlayNObject graphics]) createGroupLayer]);
    JreOperatorRetainedAssign(&gridLayer_, self, [((id<PlaynCoreGraphics>) [TBPlayNObject graphics]) createGroupLayer]);
    [((id<PlaynCoreGroupLayer>) NIL_CHK(layer__)) addWithPlaynCoreLayer:gridLayer_];
    JreOperatorRetainedAssign(&overlayLayer_, self, [((id<PlaynCoreGraphics>) [TBPlayNObject graphics]) createGroupLayer]);
    (void) [((id<PlaynCoreGroupLayer>) NIL_CHK(overlayLayer_)) setDepthWithFloat:1];
    [((id<PlaynCoreGroupLayer>) NIL_CHK(layer__)) addWithPlaynCoreLayer:overlayLayer_];
    JreOperatorRetainedAssign(&walkerStart_, self, [[[PythagorasIPoint alloc] initWithInt:rows / 2 withInt:0] autorelease]);
    JreOperatorRetainedAssign(&walkerDestination_, self, [[[PythagorasIPoint alloc] initWithInt:rows / 2 withInt:cols - 1] autorelease]);
    for (int i = 0; i < rows; i++) {
      if (i != rows / 2) {
        [((IOSBooleanArray *) [((IOSObjectArray *) NIL_CHK(passability_)) objectAtIndex:i]) replaceBooleanAtIndex:0 withBoolean:NO];
        [((IOSBooleanArray *) [((IOSObjectArray *) NIL_CHK(passability_)) objectAtIndex:i]) replaceBooleanAtIndex:cols - 1 withBoolean:NO];
      }
    }
    for (int i = 0; i < cols; i++) {
      [((IOSBooleanArray *) [((IOSObjectArray *) NIL_CHK(passability_)) objectAtIndex:0]) replaceBooleanAtIndex:i withBoolean:NO];
      [((IOSBooleanArray *) [((IOSObjectArray *) NIL_CHK(passability_)) objectAtIndex:rows - 1]) replaceBooleanAtIndex:i withBoolean:NO];
    }
    [self refreshPath];
    [self createGridSprite];
    JreOperatorRetainedAssign(&particles__, self, [[[TPTuxParticles alloc] init] autorelease]);
    JreOperatorRetainedAssign(&level__, self, [TBLevel generate]);
    [((TBLevel *) NIL_CHK(level__)) setRoundCompletedListenerWithTBLevel_RoundCompletedListener:self];
  }
  return self;
}

- (TPEmitter *)createEmitterWithInt:(int)maxParticles
                 withPlaynCoreImage:(id<PlaynCoreImage>)image {
  TPEmitter *e = [((TPParticles *) NIL_CHK(particles__)) createEmitterWithInt:maxParticles withPlaynCoreImage:image withPlaynCoreGroupLayer:overlayLayer_];
  return e;
}

- (void)fadeInWithFloat:(float)targetAlpha {
  self.targetAlpha = targetAlpha;
  (void) [((id<PlaynCoreGroupLayer>) NIL_CHK(layer__)) setAlphaWithFloat:0];
}

- (void)updateWithInt:(int)delta {
  if ([((id<PlaynCoreGroupLayer>) NIL_CHK(layer__)) alpha] < targetAlpha_ * 0.99f) {
    (void) [((id<PlaynCoreGroupLayer>) NIL_CHK(layer__)) setAlphaWithFloat:[TBPlayNObject lerpTimeWithFloat:[((id<PlaynCoreGroupLayer>) NIL_CHK(layer__)) alpha] withFloat:targetAlpha_ withFloat:0.99f withFloat:delta]];
  }
  else {
    (void) [((id<PlaynCoreGroupLayer>) NIL_CHK(layer__)) setAlphaWithFloat:targetAlpha_];
  }
  TBWalker *walker = [((TBLevel *) NIL_CHK(level__)) updateWithInt:delta];
  if (walker != nil) {
    [self addWalkerWithTBWalker:[walker placeWithTBDGrid:self withPythagorasIPoint:walkerStart_ withPythagorasIPoint:walkerDestination_ withFloat:0]];
  }
  int nObjects = [((TBMultiList *) NIL_CHK(gridObjects_)) size];
  for (int i = 0; i < nObjects; i++) {
    TBDGridObject *gridObject = ((TBDGridObject *) [((TBMultiList *) NIL_CHK(gridObjects_)) getWithInt:i]);
    if ([((TBDGridObject *) NIL_CHK(gridObject)) updateWithInt:delta]) {
      [((TBMultiList *) NIL_CHK(gridObjects_)) removeWithId:gridObject];
      i--;
      nObjects--;
      continue;
    }
  }
  [self updateToPlace];
}

- (void)paintWithPlaynCoreUtilClock:(id<PlaynCoreUtilClock>)clock {
  int nObjects = [((TBMultiList *) NIL_CHK(gridObjects_)) size];
  for (int i = 0; i < nObjects; i++) {
    TBDGridObject *gridObject = ((TBDGridObject *) [((TBMultiList *) NIL_CHK(gridObjects_)) getWithInt:i]);
    [((TBDGridObject *) NIL_CHK(gridObject)) paintWithPlaynCoreUtilClock:clock];
  }
  [((TPParticles *) NIL_CHK(particles__)) paintWithPlaynCoreUtilClock:clock];
}

- (void)refreshPath {
  JreOperatorRetainedAssign(&currentPath__, self, [TBDPathing getPathWithTBDGrid:self withPythagorasIPoint:walkerStart_ withPythagorasIPoint:walkerDestination_]);
}

- (void)addWalkerWithTBWalker:(TBWalker *)walker {
  [((id<JavaUtilList>) NIL_CHK(walkers_)) addWithId:walker];
  [((id<PlaynCoreGroupLayer>) NIL_CHK(gridLayer_)) addWithPlaynCoreLayer:[((TBWalker *) NIL_CHK(walker)) layerAddable]];
}

- (void)createGridSprite {
  if (gridSprite_ != nil) {
    [((id<PlaynCoreGroupLayer>) NIL_CHK(gridLayer_)) removeWithPlaynCoreLayer:gridSprite_];
  }
  id<PlaynCoreCanvasImage> image = [((id<PlaynCoreGraphics>) [TBPlayNObject graphics]) createImageWithFloat:[self width] withFloat:[self height]];
  id<PlaynCoreCanvas> canvas = [((id<PlaynCoreCanvasImage>) NIL_CHK(image)) canvas];
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) setFillColorWithInt:[TripleplayUtilColors WHITE]];
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) fillRectWithFloat:0 withFloat:0 withFloat:[self width] withFloat:[self height]];
  (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) setStrokeColorWithInt:[TripleplayUtilColors BLACK]];
  for (int i = 0; i < rows__; i++) {
    for (int j = 0; j < cols__; j++) {
      int x = j * cellSize__;
      int y = i * cellSize__;
      (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) setFillColorWithInt:[TripleplayUtilColors WHITE]];
      if (![((IOSBooleanArray *) [((IOSObjectArray *) NIL_CHK(passability_)) objectAtIndex:i]) booleanAtIndex:j]) {
        (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) setFillColorWithInt:[TripleplayUtilColors GRAY]];
      }
      (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) fillRectWithFloat:x withFloat:y withFloat:cellSize__ withFloat:cellSize__];
      if (TBDGrid_SHOW_GRID) (void) [((id<PlaynCoreCanvas>) NIL_CHK(canvas)) strokeRectWithFloat:x withFloat:y withFloat:cellSize__ withFloat:cellSize__];
    }
  }
  JreOperatorRetainedAssign(&gridSprite_, self, [((id<PlaynCoreGraphics>) [TBPlayNObject graphics]) createImageLayerWithPlaynCoreImage:image]);
  [((id<PlaynCoreGroupLayer>) NIL_CHK(gridLayer_)) addWithPlaynCoreLayer:gridSprite_];
  (void) [((id<PlaynCoreImageLayer>) NIL_CHK(gridSprite_)) setDepthWithFloat:-1];
}

- (PythagorasIPoint *)getCellWithFloat:(float)x
                             withFloat:(float)y {
  int r = [JavaLangMath minWithInt:[JavaLangMath maxWithInt:(int) y / cellSize__ withInt:0] withInt:rows__ - 1];
  int c = [JavaLangMath minWithInt:[JavaLangMath maxWithInt:(int) x / cellSize__ withInt:0] withInt:cols__ - 1];
  return [[[PythagorasIPoint alloc] initWithInt:r withInt:c] autorelease];
}

- (PythagorasIPoint *)getCellWithFloat:(float)x
                             withFloat:(float)y
                             withFloat:(float)width
                             withFloat:(float)height {
  return [self getCellWithFloat:x - width / 2 + [self cellSize] / 2 withFloat:y - height / 2 + [self cellSize] / 2];
}

- (float)getPlaceXWithFloat:(float)globalX {
  float placeX = globalX - [TBPlayNObject getGlobalTxWithPlaynCoreLayer:gridLayer_];
  if ([((id<PlaynCoreTouch>) [((id<PlaynCorePlatform>) [PlaynCorePlayN platform]) touch]) hasTouch]) placeX -= [self width] / 20;
  return placeX;
}

- (float)getPlaceYWithFloat:(float)globalY {
  float placeY = globalY - [TBPlayNObject getGlobalTyWithPlaynCoreLayer:gridLayer_];
  if ([((id<PlaynCoreTouch>) [((id<PlaynCorePlatform>) [PlaynCorePlayN platform]) touch]) hasTouch]) placeY -= [self width] / 20;
  return placeY;
}

- (void)startPlacementWithTBTower:(TBTower *)toPlace {
  self.toPlace = toPlace;
  (void) [((TBTower *) NIL_CHK(toPlace)) previewWithTBDGrid:self];
  [[((TBTower *) NIL_CHK(toPlace)) layer] setVisibleWithBOOL:NO];
  [((id<PlaynCoreGroupLayer>) NIL_CHK(overlayLayer_)) addWithPlaynCoreLayer:[((TBTower *) NIL_CHK(toPlace)) layerAddable]];
  [((JavaUtilHashMap *) NIL_CHK(validPlacementMap_)) clear];
  JreOperatorRetainedAssign(&toPlaceRadius_, self, [((id<PlaynCoreGraphics>) [TBPlayNObject graphics]) createImageLayerWithPlaynCoreImage:[((TBTower *) NIL_CHK(toPlace)) createRadiusImage]]);
  [TBPlayNObject centerImageLayerWithPlaynCoreImageLayer:toPlaceRadius_];
  [((id<PlaynCoreGroupLayer>) NIL_CHK(gridLayer_)) addWithPlaynCoreLayer:toPlaceRadius_];
  [self updateToPlace];
}

- (void)updatePlacementWithFloat:(float)globalX
                       withFloat:(float)globalY {
  float placeX = [self getPlaceXWithFloat:globalX], placeY = [self getPlaceYWithFloat:globalY];
  if (toPlace_ != nil) {
    PythagorasIPoint *cell = [self getCellWithFloat:placeX withFloat:placeY withFloat:[toPlace_ baseWidth] withFloat:[toPlace_ baseHeight]];
    [toPlace_ setCoordinatesWithPythagorasIPoint:cell];
    [[toPlace_ layer] setVisibleWithBOOL:![self isOutOfBoundsWithFloat:placeX withFloat:placeY]];
    [self updateToPlace];
  }
}

- (BOOL)endPlacementWithFloat:(float)globalX
                    withFloat:(float)globalY {
  BOOL canPlace = [self canPlace];
  if (canPlace) {
    (void) [((TBTower *) NIL_CHK(toPlace_)) placeWithTBDGrid:self withPythagorasIPoint:[((TBTower *) NIL_CHK(toPlace_)) coordinates]];
    [((id<PlaynCoreGroupLayer>) NIL_CHK(overlayLayer_)) removeWithPlaynCoreLayer:[((TBTower *) NIL_CHK(toPlace_)) layerAddable]];
    [((id<PlaynCoreGroupLayer>) NIL_CHK(gridLayer_)) addWithPlaynCoreLayer:[((TBTower *) NIL_CHK(toPlace_)) layerAddable]];
    [((id<JavaUtilList>) NIL_CHK(towers_)) addWithId:toPlace_];
    [((id<PlaynCoreImageLayer>) NIL_CHK(toPlaceRadius_)) destroy];
    [self refreshPath];
  }
  else if (toPlace_ != nil) {
    [[toPlace_ layer] destroy];
  }
  JreOperatorRetainedAssign(&toPlace_, self, nil);
  [((id<PlaynCoreImageLayer>) NIL_CHK(toPlaceRadius_)) destroy];
  JreOperatorRetainedAssign(&toPlaceRadius_, self, nil);
  return canPlace;
}

- (void)updateToPlace {
  if (toPlace_ == nil) return;
  [[((TBTower *) NIL_CHK(toPlace_)) layer] setAlphaWithFloat:[self canPlace] ? 1 : 0.5f];
  (void) [((id<PlaynCoreImageLayer>) NIL_CHK(toPlaceRadius_)) setTranslationWithFloat:[((TBTower *) NIL_CHK(toPlace_)) position].x_ withFloat:[((TBTower *) NIL_CHK(toPlace_)) position].y_];
  (void) [((id<PlaynCoreImageLayer>) NIL_CHK(toPlaceRadius_)) setVisibleWithBOOL:[[((TBTower *) NIL_CHK(toPlace_)) layer] visible] && [[((TBTower *) NIL_CHK(toPlace_)) layer] alpha] == 1];
}

- (BOOL)canPlace {
  if (toPlace_ == nil) return NO;
  PythagorasIPoint *p = [((TBTower *) NIL_CHK(toPlace_)) coordinates];
  int rows = [((TBTower *) NIL_CHK(toPlace_)) rows], cols = [((TBTower *) NIL_CHK(toPlace_)) cols];
  if (((PythagorasIPoint *) NIL_CHK(p)).x_ < 0 || ((PythagorasIPoint *) NIL_CHK(p)).x_ + rows > self.rows_ || ((PythagorasIPoint *) NIL_CHK(p)).y_ < 0 || ((PythagorasIPoint *) NIL_CHK(p)).y_ + cols > self.cols_) {
    return NO;
  }
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      {
        id<JavaUtilIterator> iter__ = ((id<JavaUtilIterator>) [((id<JavaUtilList>) NIL_CHK(walkers_)) iterator]);
        while ([((id<JavaUtilIterator>) NIL_CHK(iter__)) hasNext]) {
          TBWalker *walker = ((TBWalker *) [((id<JavaUtilIterator>) NIL_CHK(iter__)) next]);
          PythagorasIPoint *walkerPos = [((TBWalker *) NIL_CHK(walker)) coordinates];
          if (((PythagorasIPoint *) NIL_CHK(walkerPos)).x_ == ((PythagorasIPoint *) NIL_CHK(p)).x_ + i && ((PythagorasIPoint *) NIL_CHK(walkerPos)).y_ == ((PythagorasIPoint *) NIL_CHK(p)).y_ + j) {
            return NO;
          }
        }
      }
    }
  }
  if ([((JavaUtilHashMap *) NIL_CHK(validPlacementMap_)) containsKeyWithId:p]) return [((JavaLangBoolean *) [((JavaUtilHashMap *) NIL_CHK(validPlacementMap_)) getWithId:p]) booleanValue];
  BOOL canPlace = [self canPlaceStaticWithPythagorasIPoint:p];
  (void) [((JavaUtilHashMap *) NIL_CHK(validPlacementMap_)) putWithId:[((PythagorasIPoint *) NIL_CHK(p)) clone] withId:[JavaLangBoolean valueOfWithBOOL:canPlace]];
  return canPlace;
}

- (BOOL)canPlaceStaticWithPythagorasIPoint:(PythagorasIPoint *)p {
  int rows = [((TBTower *) NIL_CHK(toPlace_)) rows], cols = [((TBTower *) NIL_CHK(toPlace_)) cols];
  if ([((PythagorasIPoint *) NIL_CHK(p)) isEqual:walkerStart_]) return NO;
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      if (![((IOSBooleanArray *) [((IOSObjectArray *) NIL_CHK(passability_)) objectAtIndex:((PythagorasIPoint *) NIL_CHK(p)).x_ + i]) booleanAtIndex:((PythagorasIPoint *) NIL_CHK(p)).y_ + j]) return NO;
    }
  }
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      [((IOSBooleanArray *) [((IOSObjectArray *) NIL_CHK(passability_)) objectAtIndex:((PythagorasIPoint *) NIL_CHK(p)).x_ + i]) replaceBooleanAtIndex:((PythagorasIPoint *) NIL_CHK(p)).y_ + j withBoolean:NO];
    }
  }
  id<JavaUtilList> path = [TBDPathing getPathWithTBDGrid:self withPythagorasIPoint:walkerStart_ withPythagorasIPoint:walkerDestination_];
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      [((IOSBooleanArray *) [((IOSObjectArray *) NIL_CHK(passability_)) objectAtIndex:((PythagorasIPoint *) NIL_CHK(p)).x_ + i]) replaceBooleanAtIndex:((PythagorasIPoint *) NIL_CHK(p)).y_ + j withBoolean:YES];
    }
  }
  return path != nil;
}

- (BOOL)fireProjectileWithTBTower:(TBTower *)tower {
  if ([((id<JavaUtilList>) NIL_CHK(walkers_)) size] == 0) return NO;
  TBWalker *target = nil;
  float targetDis = JavaLangFloat_MAX_VALUE;
  {
    id<JavaUtilIterator> iter__ = ((id<JavaUtilIterator>) [((id<JavaUtilList>) NIL_CHK(walkers_)) iterator]);
    while ([((id<JavaUtilIterator>) NIL_CHK(iter__)) hasNext]) {
      TBWalker *walker = ((TBWalker *) [((id<JavaUtilIterator>) NIL_CHK(iter__)) next]);
      if (![((TBWalker *) NIL_CHK(walker)) isAlive]) continue;
      float dis = [[((TBWalker *) NIL_CHK(walker)) position] distanceWithPythagorasFIVector:[((TBTower *) NIL_CHK(tower)) position]];
      if (dis < [((TBTower *) NIL_CHK(tower)) range] * cellSize__) {
        if (walker == [((TBTower *) NIL_CHK(tower)) lastTarget]) {
          target = walker;
          targetDis = dis;
          break;
        }
        else if (dis < targetDis) {
          target = walker;
          targetDis = dis;
        }
      }
    }
  }
  [((TBTower *) NIL_CHK(tower)) setLastTargetWithTBWalker:target];
  if (target == nil) return NO;
  TBProjectile *p = [((TBTower *) NIL_CHK(tower)) createProjectile];
  [((TBProjectile *) NIL_CHK(p)) placeWithTBDGrid:self withTBWalker:target withTBTower:tower];
  [((id<PlaynCoreGroupLayer>) NIL_CHK(gridLayer_)) addWithPlaynCoreLayer:[((TBProjectile *) NIL_CHK(p)) layer]];
  [((id<JavaUtilList>) NIL_CHK(projectiles_)) addWithId:p];
  return YES;
}

- (BOOL)fireProjectileWithTBChainProjectile:(TBChainProjectile *)from {
  if ([((id<JavaUtilList>) NIL_CHK(walkers_)) size] == 0) return NO;
  TBWalker *target = nil;
  float targetDis = JavaLangFloat_MAX_VALUE;
  {
    id<JavaUtilIterator> iter__ = ((id<JavaUtilIterator>) [((id<JavaUtilList>) NIL_CHK(walkers_)) iterator]);
    while ([((id<JavaUtilIterator>) NIL_CHK(iter__)) hasNext]) {
      TBWalker *walker = ((TBWalker *) [((id<JavaUtilIterator>) NIL_CHK(iter__)) next]);
      if (![((TBWalker *) NIL_CHK(walker)) isAlive]) continue;
      if ([((TBChainProjectile *) NIL_CHK(from)) partOfChainWithTBWalker:walker]) continue;
      float dis = [[((TBWalker *) NIL_CHK(walker)) position] distanceWithPythagorasFIVector:[[((TBChainProjectile *) NIL_CHK(from)) target] position]];
      if (dis < [((TBChainProjectile *) NIL_CHK(from)) range] * cellSize__ && dis < targetDis) {
        target = walker;
        targetDis = dis;
      }
    }
  }
  if (target == nil) return NO;
  TBChainProjectile *p = [((TBChainProjectile *) NIL_CHK(from)) createProjectile];
  [((TBChainProjectile *) NIL_CHK(p)) placeWithTBDGrid:self withTBWalker:target withTBChainProjectile:from];
  [((id<PlaynCoreGroupLayer>) NIL_CHK(gridLayer_)) addWithPlaynCoreLayer:[((TBChainProjectile *) NIL_CHK(p)) layer]];
  [((id<JavaUtilList>) NIL_CHK(projectiles_)) addWithId:p];
  return YES;
}

- (void)dealDamageWithTBTower:(TBTower *)source
                 withTBWalker:(TBWalker *)target
                    withFloat:(float)damage
        withPythagorasFVector:(PythagorasFVector *)hit {
  if ([((TBTower *) NIL_CHK(source)) splashRadius] == 0) {
    [((TBWalker *) NIL_CHK(target)) damageWithFloat:damage];
    [((TBTower *) NIL_CHK(source)) addBuffsWithTBWalker:target];
  }
  else {
    float actualRadius = [((TBTower *) NIL_CHK(source)) splashRadius] * cellSize__;
    {
      id<JavaUtilIterator> iter__ = ((id<JavaUtilIterator>) [((id<JavaUtilList>) NIL_CHK(walkers_)) iterator]);
      while ([((id<JavaUtilIterator>) NIL_CHK(iter__)) hasNext]) {
        TBWalker *walker = ((TBWalker *) [((id<JavaUtilIterator>) NIL_CHK(iter__)) next]);
        float distance = [[((TBWalker *) NIL_CHK(walker)) position] distanceWithPythagorasFIVector:hit];
        float perc = (actualRadius - distance) / actualRadius;
        float dealt = perc * damage;
        if (dealt > 0) {
          [((TBWalker *) NIL_CHK(walker)) damageWithFloat:dealt];
          [((TBTower *) NIL_CHK(source)) addBuffsWithTBWalker:walker];
        }
      }
    }
  }
}

- (TBWalker *)getHitWalkerWithPythagorasFVector:(PythagorasFVector *)position {
  {
    id<JavaUtilIterator> iter__ = ((id<JavaUtilIterator>) [((id<JavaUtilList>) NIL_CHK(walkers_)) iterator]);
    while ([((id<JavaUtilIterator>) NIL_CHK(iter__)) hasNext]) {
      TBWalker *walker = ((TBWalker *) [((id<JavaUtilIterator>) NIL_CHK(iter__)) next]);
      if (![((TBWalker *) NIL_CHK(walker)) isAlive]) continue;
      float dx = [((TBWalker *) NIL_CHK(walker)) position].x_ - ((PythagorasFVector *) NIL_CHK(position)).x_;
      float dy = [((TBWalker *) NIL_CHK(walker)) position].y_ - ((PythagorasFVector *) NIL_CHK(position)).y_;
      if ([JavaLangMath absWithFloat:dx] < [((TBWalker *) NIL_CHK(walker)) width] / 2 && [JavaLangMath absWithFloat:dy] < [((TBWalker *) NIL_CHK(walker)) height] / 2) {
        return walker;
      }
    }
  }
  return nil;
}

- (BOOL)isOutOfBoundsWithPythagorasFVector:(PythagorasFVector *)position {
  return [self isOutOfBoundsWithFloat:((PythagorasFVector *) NIL_CHK(position)).x_ withFloat:((PythagorasFVector *) NIL_CHK(position)).y_];
}

- (BOOL)isOutOfBoundsWithFloat:(float)x
                     withFloat:(float)y {
  return x < 0 || y < 0 || x >= [self width] || y >= [self height];
}

- (void)addEffectWithTBEffect:(TBEffect *)effect {
  [((id<JavaUtilList>) NIL_CHK(effects_)) addWithId:effect];
  (void) [((id<PlaynCoreLayer>) [((TBEffect *) NIL_CHK(effect)) layer]) setDepthWithFloat:5];
  [((id<PlaynCoreGroupLayer>) NIL_CHK(gridLayer_)) addWithPlaynCoreLayer:[((TBEffect *) NIL_CHK(effect)) layer]];
}

- (void)onRoundCompletedWithTBRound:(TBRound *)round {
  [((TBRound *) NIL_CHK(round)) winRoundWithTBGameState:state_];
}

- (void)dealloc {
  JreOperatorRetainedAssign(&validPlacementMap_, self, nil);
  JreOperatorRetainedAssign(&state_, self, nil);
  JreOperatorRetainedAssign(&particles__, self, nil);
  JreOperatorRetainedAssign(&level__, self, nil);
  JreOperatorRetainedAssign(&currentPath__, self, nil);
  JreOperatorRetainedAssign(&toPlaceRadius_, self, nil);
  JreOperatorRetainedAssign(&toPlace_, self, nil);
  JreOperatorRetainedAssign(&walkerDestination_, self, nil);
  JreOperatorRetainedAssign(&walkerStart_, self, nil);
  JreOperatorRetainedAssign(&gridObjects_, self, nil);
  JreOperatorRetainedAssign(&effects_, self, nil);
  JreOperatorRetainedAssign(&towers_, self, nil);
  JreOperatorRetainedAssign(&projectiles_, self, nil);
  JreOperatorRetainedAssign(&walkers_, self, nil);
  JreOperatorRetainedAssign(&passability_, self, nil);
  JreOperatorRetainedAssign(&gridSprite_, self, nil);
  JreOperatorRetainedAssign(&overlayLayer_, self, nil);
  JreOperatorRetainedAssign(&gridLayer_, self, nil);
  JreOperatorRetainedAssign(&layer__, self, nil);
  [super dealloc];
}

- (void)copyAllPropertiesTo:(id)copy {
  [super copyAllPropertiesTo:copy];
  TBDGrid *typedCopy = (TBDGrid *) copy;
  typedCopy.cellSize_ = cellSize__;
  typedCopy.rows_ = rows__;
  typedCopy.cols_ = cols__;
  typedCopy.layer_ = layer__;
  typedCopy.gridLayer = gridLayer_;
  typedCopy.overlayLayer = overlayLayer_;
  typedCopy.gridSprite = gridSprite_;
  typedCopy.passability = passability_;
  typedCopy.walkers = walkers_;
  typedCopy.projectiles = projectiles_;
  typedCopy.towers = towers_;
  typedCopy.effects = effects_;
  typedCopy.gridObjects = gridObjects_;
  typedCopy.walkerStart = walkerStart_;
  typedCopy.walkerDestination = walkerDestination_;
  typedCopy.toPlace = toPlace_;
  typedCopy.toPlaceRadius = toPlaceRadius_;
  typedCopy.currentPath_ = currentPath__;
  typedCopy.level_ = level__;
  typedCopy.targetAlpha = targetAlpha_;
  typedCopy.towerColor_ = towerColor__;
  typedCopy.particles_ = particles__;
  typedCopy.state = state_;
  typedCopy.validPlacementMap = validPlacementMap_;
}

@end
